<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java笔试 - ACM模式处理输入输出</title>
    <link href="/2022/04/29/10.Java%E7%AC%94%E8%AF%95%20-%20ACM%E6%A8%A1%E5%BC%8F%E5%A4%84%E7%90%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <url>/2022/04/29/10.Java%E7%AC%94%E8%AF%95%20-%20ACM%E6%A8%A1%E5%BC%8F%E5%A4%84%E7%90%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="Java笔试-ACM模式处理输入输出"><a href="#Java笔试-ACM模式处理输入输出" class="headerlink" title="Java笔试: ACM模式处理输入输出"></a>Java笔试: ACM模式处理输入输出</h2><p>大部分公司都会使用牛客网来进行笔试，当然其中和我们常刷题的leetcode有个重要的不同点就是程序的输入和输出。leetcode模式不需要我们自己去输入测试用例，而是封装一个Solution类由系统调用。而ACM模式则需要我们编写代码手动输入程序的参数和输出程序的结果。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>基本的框架可以如下方式构建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>      <span class="hljs-comment">//1. 使用Scanner构建扫描器 </span><br>      Scanner cin = <span class="hljs-keyword">new</span> Scanner(System.in);<br>      <span class="hljs-comment">//2. 根据题目自定义输入格式</span><br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述步骤二中，我们需要根据题目来自定义输入格式，比如：</p><ol><li><p>读取一个整数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//int</span><br>cin.nextInt();<br><span class="hljs-comment">//long</span><br>cin.nextLong();<br></code></pre></td></tr></table></figure></li><li><p>读取一个字符或者字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//String</span><br>cin.next();<br></code></pre></td></tr></table></figure></li><li><p>读取一个浮点数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//double</span><br>cin.nextDouble();<br><span class="hljs-comment">//float</span><br>cin.nextFloat();<br></code></pre></td></tr></table></figure></li><li><p>读取一整行（返回String）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//String</span><br>cin.nextLine();<br></code></pre></td></tr></table></figure></li><li><p>循环读取</p><p>有些题目会设置循环读取参数，判断是否还有下一个输入可以用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//boolean</span><br>cin.hasNext()<br></code></pre></td></tr></table></figure><p>如果题目中没有说明一次给几个输入，为了保险起见可以直接用<code>while(cin.hasNext())&#123;&#125;</code>将输入包括起来。</p><p>或者就是根据题目设定，先读取数据组数，再设定循环处理数据（如下方例1）</p></li></ol><blockquote><p>其中next()方法读取到空白符就结束，但是nextLine()读取到回车结束也就是‘\t’。</p></blockquote><p><strong>如果要在next(), nextDouble(), nextFloat(), nextInt()等语句之后使用nextLine()时，需要再加一个nextLine()语句，将被next()去掉的Enter结束符过滤掉。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Scanner cin = <span class="hljs-keyword">new</span> Scanner(System.in);<br>       <span class="hljs-keyword">int</span> num1 = cin.nextInt();<br>       <span class="hljs-keyword">int</span> nums2 = cin.nextInt();<br>       cin.nextLine(); <span class="hljs-comment">//容易漏掉</span><br>       String a_b_c = cin.nextLine();<br>       <span class="hljs-comment">//这样才能读取到正确的内容。</span><br>       <span class="hljs-comment">//不加sc.nextLine()的话，a_b_c是一个Enter字符。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一般输出</span><br>System.out.print(); <br><span class="hljs-comment">//换行输出</span><br>System.out.println(); <br><span class="hljs-comment">//格式化输出 (有可能在需要四舍五入输出时需要该方法)</span><br>System.out.format(<span class="hljs-string">&quot;%.2f&quot;</span>,<span class="hljs-number">1.23</span>);<br><span class="hljs-comment">//格式化输出</span><br>System.out.printf(<span class="hljs-string">&quot;这是换行符%n&quot;</span>);  <br></code></pre></td></tr></table></figure><h3 id="例1-重复固定位数的参数"><a href="#例1-重复固定位数的参数" class="headerlink" title="例1 重复固定位数的参数"></a>例1 重复固定位数的参数</h3><p>以牛客网[AB28 快速幂][<a href="https://www.nowcoder.com/practice/defdedf4fe984c6c91eefa6b00d5f4f0?tpId=308&amp;tqId=2403107&amp;ru=/exam/oj&amp;qru=/ta/algorithm-start/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D308]为例，第一个数输入为调用方法的次数，也就是执行q组参数，但是输入参数个数是固定的3个：">https://www.nowcoder.com/practice/defdedf4fe984c6c91eefa6b00d5f4f0?tpId=308&amp;tqId=2403107&amp;ru=/exam/oj&amp;qru=/ta/algorithm-start/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D308]为例，第一个数输入为调用方法的次数，也就是执行q组参数，但是输入参数个数是固定的3个：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">输入： <span class="hljs-number">2</span><br>  <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span><br>  <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">10</span><br><br>输出： <span class="hljs-number">4</span><br>    <span class="hljs-number">1</span><br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//1. 构建Scanner获取输入 </span><br>        Scanner cin = <span class="hljs-keyword">new</span> Scanner(System.in);<br>      <span class="hljs-comment">//2. 获取执行次数并且设置循环 </span><br>        <span class="hljs-keyword">long</span> q = cin.nextInt();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; q;i++)&#123;<br>          <span class="hljs-comment">//3. 按顺序获取每组的固定参数</span><br>            <span class="hljs-keyword">long</span> a = cin.nextInt();<br>            <span class="hljs-keyword">long</span> b = cin.nextInt();<br>            <span class="hljs-keyword">long</span> p = cin.nextInt();<br><span class="hljs-comment">//...</span><br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例2-读取二维数组"><a href="#例2-读取二维数组" class="headerlink" title="例2 读取二维数组"></a>例2 读取二维数组</h3><p>为了读取题目要求的二维数组，我们应该先读取二维数组的长度和宽度存在两个整数中。在下一行将一串整型数字存入二维数组中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">输入： <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>  <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>  <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br>  <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>  <br>Scanner cin = <span class="hljs-keyword">new</span> Scanner(System.in);<br><span class="hljs-keyword">while</span>(cin.hasNext()) &#123;<br>    <span class="hljs-keyword">int</span> r = cin.nextInt();<br>    <span class="hljs-keyword">int</span> c = cin.nextInt();<br>    <span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r][c];<br>    cin.nextLine(); <span class="hljs-comment">// 跳过行数和列数后的换行符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;r;i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; c; j++) &#123;<br>            matrix[i][j] = cin.nextInt();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>笔试技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自动装配原理与实践</title>
    <link href="/2022/04/29/11.SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/04/29/11.SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h2><p>首先看一段@SpringBootApplication的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span> <br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <br><span class="hljs-meta">@Documented</span> <br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span> <br><span class="hljs-meta">@EnableAutoConfiguration</span> <br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h3><p>如图所示，<code>@SpringBootApplication</code>注解中，除了元注解之外，主要包含了三个核心注解，分别是：</p><ol><li><p><code>@SpringBootConfiguration</code>：@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。</p></li><li><p><code>@ComponentScan</code>：该注解默认会扫描该类所在的包下所有的配置类—由<code>@Component</code>注解（衍生注解包括<code>@Service</code>，<code>@Controller</code>和<code>@Repository</code>）修饰的bean。这个注解还支持@Filter注解排除某些不扫描的bean。如源码所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</p></li><li><p>@EnableAutoConfiguration：真正启用SpringBoot的自动配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Environment property that can be used to override when auto-configuration is</span><br><span class="hljs-comment"> * enabled.</span><br><span class="hljs-comment"> */</span><br>String ENABLED_OVERRIDE_PROPERTY = <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the classes to exclude</span><br><span class="hljs-comment"> */</span><br>Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Exclude specific auto-configuration class names such that they will never be</span><br><span class="hljs-comment"> * applied.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the class names to exclude</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.3.0</span><br><span class="hljs-comment"> */</span><br>String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><img src="./img/spring-boot-auto-configuration.png"></p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><code>@EnableAutoConfiguration</code>又包含两个重要的注解，分别是==@AutoConfigurationPackage==和==@Import(AutoConfigurationImportSelector.class)==</p><p>其中<code>@AutoConfigurationPackage</code>注解被@Import(AutoConfigurationPackages.Registrar.class)修饰，通过ImportBeanDefinitionRegistrar.registerBeanDefinitions()来存储导入配置里的基础包(base packages)，其实从名字就可以看出，就是注册扫描路径里的组件到容器的全局中，提供查询。</p><p>@Import(==AutoConfigurationImportSelector==.class)中导入的AutoConfigurationImportSelector继承体系如下(2.6.5版本)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DeferredImportSelector</span>, <span class="hljs-title">BeanClassLoaderAware</span>, <span class="hljs-title">ResourceLoaderAware</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">EnvironmentAware</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>      <span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123; <span class="hljs-comment">//判断自动装配开关是否打开</span><br>        <span class="hljs-keyword">return</span> NO_IMPORTS; <span class="hljs-comment">// private static final String[] NO_IMPORTS = &#123;&#125;;</span><br>      &#125;<br>      <span class="hljs-comment">//</span><br>      AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);<br>      <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DeferredImportSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    String[] selectImports(AnnotationMetadata importingClassMetadata);<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;String&gt; <span class="hljs-title">getExclusionFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，<code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，实现了这个接口中的 <code>selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IOC 容器中</strong>。</p><blockquote><p>如果@Import引入的是ImportSelector的子类，将它添加到DeferredImportSelectorHandler实例中，预留到所有的配置类加载完成后统一处理自动化配置类<br>此类（ImportSelector）的主要功能是：根据给定的条件（通常是一个或多个注解属性）判断要导入哪个配置类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br><span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>&#125;<br>   <span class="hljs-comment">//attributes里包含了“exclude”和“excludeName”两个字符串数组对象，这其实是@EnableAutoConfiguration注解里的不使用自动装配的类</span><br>AnnotationAttributes attributes = getAttributes(annotationMetadata);<br>   <span class="hljs-comment">//扫描具有META-INF/spring.factories文件的jar包</span><br>   <span class="hljs-comment">//包括依赖里的 /spring-boot/META-INF/spring.factories 和 /spring-boot-autoconfigure/META-INF/spring.factories</span><br>   <span class="hljs-comment">//还包括工程项目Spring Boot Starter里的/resources/META-INF/spring.factories</span><br>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);<br>   <span class="hljs-comment">//jar包去重</span><br>configurations = removeDuplicates(configurations);<br>   <span class="hljs-comment">//删除需要排除的类</span><br>Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);<br>checkExcludedClasses(configurations, exclusions);<br>configurations.removeAll(exclusions);<br>   <span class="hljs-comment">//过滤器</span><br>configurations = getConfigurationClassFilter().filter(configurations);<br>fireAutoConfigurationImportEvents(configurations, exclusions);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutoConfigurationEntry(configurations, exclusions);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的过滤器其实就是@OnXXXCondition注解，意思是满足XXX的条件才能被视为自动配置类：</p><p><img src="./img/spring-boot-filters.png"></p><p>如@ConditionOnClass注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span><br><span class="hljs-comment">// 存在才会加载</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; RabbitTemplate.class, Channel.class &#125;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(RabbitProperties.class)</span><br><span class="hljs-meta">@Import(RabbitAnnotationDrivenConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitAutoConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现一个自定义的Starter"><a href="#实现一个自定义的Starter" class="headerlink" title="实现一个自定义的Starter"></a>实现一个自定义的Starter</h2><p>从上述流程中我们其实已经知道了SpringBoot自动配置的原理，可以选择实现我们自己的Starter。</p><h3 id="为什么要自定义starter"><a href="#为什么要自定义starter" class="headerlink" title="为什么要自定义starter"></a>为什么要自定义starter</h3><p>starter是一组方便的依赖描述符，当我们使用它时，可以获得所有需要的Spring和相关技术的一站式服务，典型的如<code>spring-boot-starter-web</code>，引入之后，自动引入所有有关spring web项目相关的依赖。如果我们在开发中有一些独立于业务之外的配置模块，我们将其封装成一个starter，就可以直接在pom文件中引入依赖，springboot会为我们实现自动装配，更加方便我们的开发。</p><h3 id="1-新建一个子工程项目"><a href="#1-新建一个子工程项目" class="headerlink" title="1. 新建一个子工程项目"></a>1. 新建一个子工程项目</h3><p>在我们的主工程下面新建一个子工程项目spring-boot-starter-demo-starter</p><p><img src="./img/spring-boot-starter-1.png"></p><h3 id="2-引入依赖"><a href="#2-引入依赖" class="headerlink" title="2. 引入依赖"></a>2. 引入依赖</h3><p>在主工程的pom文件中插入自定义的starter</p><p><img src="./img/spring-boot-starter-2.png" style="width:60%"></p><h3 id="3-编写Starter中代码"><a href="#3-编写Starter中代码" class="headerlink" title="3. 编写Starter中代码"></a>3. 编写Starter中代码</h3><h4 id="DemoTestHandler"><a href="#DemoTestHandler" class="headerlink" title="DemoTestHandler"></a>DemoTestHandler</h4><p>用于注入测试的Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoTestHandler</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoTestHandler</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        System.out.println(<span class="hljs-string">&quot;Init DemoTest&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;DemoTest &quot;</span> + name + <span class="hljs-string">&quot; Refresh&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="监听器-DemoTestListener"><a href="#监听器-DemoTestListener" class="headerlink" title="监听器 DemoTestListener"></a>监听器 DemoTestListener</h4><p>监听器肯定是对应着一系列的事件的，有个事件叫做<code>ContextRefreshedEvent</code>, 表示Spring的上下文刷新完毕，所有的Bean都已经初始化完成，Spring的启动流程即将结束。通过加入监听器我们可以在DemoTestHandler初始化完毕之后做一些事情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoTestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ContextRefreshedEvent</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DemoTestHandler demoTestHandler;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Listener:&quot;</span>);<br>        demoTestHandler.refresh();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="配置DemoTestAutoConfiguration"><a href="#配置DemoTestAutoConfiguration" class="headerlink" title="配置DemoTestAutoConfiguration"></a>配置DemoTestAutoConfiguration</h4><p>通过注解@Bean注入DemoTestHandler和DemoTestListener到容器中，@ConditionalOnClass表示监视器依赖于DemoHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoTestAutoConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DemoTestHandler <span class="hljs-title">MyDemoTest</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DemoTestHandler(<span class="hljs-string">&quot;Bean&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnClass(DemoTestHandler.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DemoTestListener <span class="hljs-title">demoTestListener</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DemoTestListener();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="加入自动装配列表"><a href="#加入自动装配列表" class="headerlink" title="加入自动装配列表"></a>加入自动装配列表</h4><p>在<code>resources</code>目录下新建<code>META-INF/spring.factories</code>文件，将配置类<code>DemoTestAutoConfiguration</code>加入启动时的自动装配</p><p><img src="./img/spring-boot-starter-3.png"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string"> com.example.DemoTestAutoConfiguration</span><br></code></pre></td></tr></table></figure><h3 id="4-启用Test进行自动装配测试"><a href="#4-启用Test进行自动装配测试" class="headerlink" title="4. 启用Test进行自动装配测试"></a>4. 启用Test进行自动装配测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootStarterDemoStarterApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    DemoTestHandler demoTestHandler;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        demoTestHandler.refresh();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="./img/spring-boot-starter-4.png" style="width:60%"></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>自动装配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 - 泛型与反射</title>
    <link href="/2022/04/29/12.Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/04/29/12.Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Java 泛型（generics） 是 JDK 5 中引入的一个新特性, <u>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型</u>。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p>泛型擦除是指 Java 在运行期间，所有的泛型信息都会被擦掉。</p><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="hljs-comment">//在实例化泛型类时，必须指定T的具体类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T key;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Generic</span><span class="hljs-params">(T key)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> Generic&lt;Integer&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure><p>除此之外，泛型个数可以自由指定，被称为多元泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Notepad</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span>&#123;       <span class="hljs-comment">// 此处指定了两个泛型类型  </span><br>    <span class="hljs-keyword">private</span> K key ;     <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">private</span> V value ;   <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.key ;  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value ;  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setKey</span><span class="hljs-params">(K key)</span></span>&#123;  <br>        <span class="hljs-keyword">this</span>.key = key ;  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(V value)</span></span>&#123;  <br>        <span class="hljs-keyword">this</span>.value = value ;  <br>    &#125;  <br>&#125; <br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericsDemo09</span></span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;  <br>        Notepad&lt;String,Integer&gt; t = <span class="hljs-keyword">null</span> ;        <span class="hljs-comment">// 定义两个泛型类型的对象  </span><br>        t = <span class="hljs-keyword">new</span> Notepad&lt;String,Integer&gt;() ;       <span class="hljs-comment">// 里面的key为String，value为Integer  </span><br>        t.setKey(<span class="hljs-string">&quot;汤姆&quot;</span>) ;        <span class="hljs-comment">// 设置第一个内容  </span><br>        t.setValue(<span class="hljs-number">20</span>) ;            <span class="hljs-comment">// 设置第二个内容  </span><br>        System.out.print(<span class="hljs-string">&quot;姓名；&quot;</span> + t.getKey()) ;      <span class="hljs-comment">// 取得信息  </span><br>        System.out.print(<span class="hljs-string">&quot;，年龄；&quot;</span> + t.getValue()) ;       <span class="hljs-comment">// 取得信息  </span><br>  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//不指定类型实现泛型接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorImpl</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//指定类型实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(E[] inputArray)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (E element : inputArray) &#123;<br>        System.out.printf(<span class="hljs-string">&quot;%s &quot;</span>, element);<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><p>调用泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建不同类型数组： Integer, Double 和 Character</span><br>Integer[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>String[] stringArray = &#123; <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span> &#125;;<br>printArray(intArray);<br>printArray(stringArray);<br></code></pre></td></tr></table></figure><p>除此之外，可以通过class类来定义泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">(Class&lt;T&gt; c)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException</span>&#123;<br>  T t = c.newInstance();<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-comment">//调用泛型方法</span><br>Generic generic = <span class="hljs-keyword">new</span> Generic();<br><span class="hljs-comment">//通过泛型返回objectName类的实例obj</span><br>Object obj = generic.getObject(Class.forName(<span class="hljs-string">&quot;com.XCC.objectName&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><img src="/Users/xuchengchuan/Library/CloudStorage/OneDrive-个人/学习笔记/java/..\static\java\java-basic-reflection.png" style="width:800px"/></p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>反射就是把java类中的各种成分映射成一个个的Java对象。</p><p>==对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性==</p><blockquote><p>这里我们首先需要理解 Class类，以及类的加载机制； 然后基于此我们如何通过反射获取Class类以及类中的成员变量、方法、构造方法等。</p></blockquote><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="C:\Users\elliot\OneDrive\学习笔记\static\java\java_jvm_classload.png" style="width:800px"/></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>动态代理和注解都依赖于反射机制实现。</p><h4 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a>获取 Class 对象的四种方式</h4><p>在类加载的时候，jvm会创建一个class对象，如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。</p><ol><li><p>具体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; alunbarClass = TargetObject.class; <span class="hljs-comment">//这里TargetObject代表的是该类的对象</span><br></code></pre></td></tr></table></figure></li><li><p>通过类的全路径（全限定类名）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; alunbarClass1 = Class.forName(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>通过对象实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">TargetObject o = <span class="hljs-keyword">new</span> TargetObject();<br>Class&lt;?&gt; alunbarClass2 = o.getClass();<br></code></pre></td></tr></table></figure></li><li><p>通过类加载器</p><p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; clazz = ClassLoader.loadClass(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="获取某个类的方法以及参数"><a href="#获取某个类的方法以及参数" class="headerlink" title="获取某个类的方法以及参数"></a>获取某个类的方法以及参数</h4><h5 id="Method-获取方法"><a href="#Method-获取方法" class="headerlink" title="Method 获取方法"></a>Method 获取方法</h5><p>适用Method反射类用来实现动态代理，适用invoke()函数能调用相应的方法。</p><p>Method类的<code>invoke(Object obj,Object... args)</code>第一个参数代表调用的对象，第二个参数传递的调用方法的参数。</p><p>值得注意的是<code>getDeclaredMethods()</code>返回的是此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。<code>getMethods()</code>返回的是所有包括继承的公共member方法。</p><div class="table-container"><table><thead><tr><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法</td></tr><tr><td>getDeclaredMethods()</td><td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法</td></tr><tr><td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法</td></tr><tr><td>getMethods()</td><td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法</td></tr></tbody></table></div><h5 id="Field-获取参数"><a href="#Field-获取参数" class="headerlink" title="Field 获取参数"></a>Field 获取参数</h5><p>Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">方法说明</th></tr></thead><tbody><tr><td style="text-align:left">getDeclaredField(String name)</td><td style="text-align:left">获取指定name名称的(包含private修饰的)字段，不包括继承的字段</td></tr><tr><td style="text-align:left">getDeclaredFields()</td><td style="text-align:left">获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段</td></tr><tr><td style="text-align:left">getField(String name)</td><td style="text-align:left">获取指定name名称、具有public修饰的字段，包含继承字段<u>（如果需要获取父类的public字段）</u></td></tr><tr><td style="text-align:left">getFields()</td><td style="text-align:left">获取修饰符为public的字段，包含继承字段</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> javaBase;<br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InvokeDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//cn.javaguide.TargetObject 是相应类的全限定类名</span><br>        Class&lt;?&gt; targetClass = Class.forName(<span class="hljs-string">&quot;javaBase.TargetObject&quot;</span>);<br>        <span class="hljs-comment">//实例化默认构造方法，TargetObject必须无参构造函数,否则将抛异常</span><br>        TargetObject targetObject = (TargetObject) targetClass.newInstance();<br><br>        <span class="hljs-comment">//获取公有的构造函数且不带参数</span><br>        Constructor&lt;?&gt; constructor = targetClass.getConstructor();<br>        System.out.println(constructor.getName());<br>        <span class="hljs-comment">//获取私有的构造函数（且带参数）</span><br>        Constructor&lt;?&gt; constructorString = targetClass.getDeclaredConstructor(String.class);<br>        <span class="hljs-comment">//通过Constructor的newInstance方法新建一个实例</span><br>        TargetObject targetObjectByCon = (TargetObject) constructorString.newInstance(<span class="hljs-string">&quot;newTargetObject&quot;</span>);<br>        targetObjectByCon.getValue();<br>        <span class="hljs-comment">//获取所有构造参数类型</span><br>        Constructor&lt;?&gt;[] constructors = targetClass.getDeclaredConstructors();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructorTemp : constructors)&#123;<br>            <span class="hljs-comment">//获取构造参数类型</span><br>            Class&lt;?&gt;[] clazz = constructorTemp.getParameterTypes();<br>            System.out.println(<span class="hljs-string">&quot;constructors&quot;</span>+count+<span class="hljs-string">&quot;: &quot;</span>);<br>            <span class="hljs-keyword">for</span> (Class&lt;?&gt; classTemp:clazz)&#123;<br>                System.out.println(classTemp.getName());<br>            &#125;<br>            count++;<br>        &#125;<br><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取 TargetObject 类中定义的所有方法</span><br><span class="hljs-comment">         */</span><br>        System.out.println(<span class="hljs-string">&quot;#########################&quot;</span>);<br>        Method[] methods = targetClass.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Method: &quot;</span>+method.getName());<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取指定方法并调用</span><br><span class="hljs-comment">         */</span><br>        Method publicMethod = targetClass.getDeclaredMethod(<span class="hljs-string">&quot;publicMethod&quot;</span>,<br>                String.class);<br>        publicMethod.invoke(targetObject, <span class="hljs-string">&quot;World&quot;</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取指定方法并调用并输出返回值</span><br><span class="hljs-comment">         */</span><br>        Method publicMethodInt = targetClass.getDeclaredMethod(<span class="hljs-string">&quot;publicMethodInt&quot;</span>,<span class="hljs-keyword">int</span>.class);<br>        System.out.println(publicMethodInt.invoke(targetObject,<span class="hljs-number">520</span>));<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取指定参数并对参数进行修改</span><br><span class="hljs-comment">         */</span><br>        System.out.println(<span class="hljs-string">&quot;#########################&quot;</span>);<br>        Field field = targetClass.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>        Field[] fields = targetClass.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field fieldItem:fields)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Field: &quot;</span>+fieldItem.getName());<br>        &#125;<br>        <span class="hljs-comment">//为了对类中的参数进行修改我们取消安全检查 如果不取消安全检查再用filed去get或set的private的字段</span><br>        field.setAccessible(<span class="hljs-keyword">true</span>);<br>        System.out.println(<span class="hljs-string">&quot;value: &quot;</span>+field.get(targetObject));<br>        field.set(targetObject, <span class="hljs-string">&quot;TargetObject2&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;value: &quot;</span>+field.get(targetObject));<br><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 调用 private 方法</span><br><span class="hljs-comment">         */</span><br>        System.out.println(<span class="hljs-string">&quot;#########################&quot;</span>);<br>        Method privateMethod = targetClass.getDeclaredMethod(<span class="hljs-string">&quot;privateMethod&quot;</span>);<br>        <span class="hljs-comment">//为了调用private方法我们取消安全检查</span><br>        privateMethod.setAccessible(<span class="hljs-keyword">true</span>);<br>        privateMethod.invoke(targetObject);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上方对应的<code>TargetObject</code>类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> javaBase;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetObject</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String staticString = <span class="hljs-string">&quot;StaticString&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> String value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TargetObject</span><span class="hljs-params">()</span> </span>&#123;<br>        value = <span class="hljs-string">&quot;TargetObject&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TargetObject</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        value = s;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">publicMethodInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;System.out.println(value);&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publicMethod</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + s);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">privateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;value is &quot;</span> + value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">javaBase.TargetObject<br>newTargetObject<br>constructors0: <br>constructors1: <br>java.lang.String<br><span class="hljs-comment">#########################</span><br>Method: getValue<br>Method: publicMethod<br>Method: publicMethodInt<br>Method: privateMethod<br>Hello World<br>520<br><span class="hljs-comment">#########################</span><br>Field: staticString<br>Field: value<br>value: TargetObject<br>value: TargetObject2<br><span class="hljs-comment">#########################</span><br>value is TargetObject2<br></code></pre></td></tr></table></figure><h4 id="Constructor-构造实例"><a href="#Constructor-构造实例" class="headerlink" title="Constructor 构造实例"></a>Constructor 构造实例</h4><p>Constructor类存在于反射包(java.lang.reflect)中，<u>反映的是Class 对象所表示的类的构造方法</u>。</p><div class="table-container"><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>static Class&lt;?&gt;</td><td>forName(String className)</td><td>返回与带有给定字符串名的类或接口相关联的 Class 对象。</td></tr><tr><td>Constructor</td><td>getConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回指定参数类型、具有public访问权限的构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getConstructors()</td><td>返回所有具有public访问权限的构造函数的Constructor对象数组</td></tr><tr><td>Constructor</td><td>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回指定参数类型、所有声明的（包括private）构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getDeclaredConstructors()</td><td>返回所有声明的（包括private）构造函数对象</td></tr><tr><td>T</td><td>newInstance()</td><td>调用无参构造器创建此 Class 对象所表示的类的一个新实例</td></tr></tbody></table></div><p>主类 ConstructionTest：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructionTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;javaBase.User&quot;</span>);<br>        <span class="hljs-comment">//获取带String参数的public构造函数</span><br>        Constructor cs1 = clazz.getConstructor(String.class);<br>        <span class="hljs-comment">//创建User</span><br>        User user1= (User) cs1.newInstance(<span class="hljs-string">&quot;hiway&quot;</span>);<br>        user1.setAge(<span class="hljs-number">22</span>);<br>        System.out.println(<span class="hljs-string">&quot;user1:&quot;</span>+user1.toString());<br><br>        System.out.println(<span class="hljs-string">&quot;#########################&quot;</span>);<br><br>        <span class="hljs-comment">//取得指定带int和String参数构造函数,该方法是私有构造private</span><br>        Constructor cs2=clazz.getDeclaredConstructor(<span class="hljs-keyword">int</span>.class,String.class);<br>        <span class="hljs-comment">//由于是private必须设置可访问</span><br>        cs2.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//创建user对象</span><br>        User user2= (User) cs2.newInstance(<span class="hljs-number">25</span>,<span class="hljs-string">&quot;hiway2&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;user2:&quot;</span>+user2.toString());<br><br>        System.out.println(<span class="hljs-string">&quot;#########################&quot;</span>);<br><br>        <span class="hljs-comment">//获取所有构造包含private</span><br>        Constructor&lt;?&gt; cons[] = clazz.getDeclaredConstructors();<br>        <span class="hljs-comment">// 查看每个构造方法需要的参数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cons.length; i++) &#123;<br>            <span class="hljs-comment">//获取构造函数参数类型</span><br>            Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes();<br>            System.out.println(<span class="hljs-string">&quot;构造函数[&quot;</span>+i+<span class="hljs-string">&quot;]:&quot;</span>+cons[i].toString() );<br>            System.out.print(<span class="hljs-string">&quot;参数类型[&quot;</span>+i+<span class="hljs-string">&quot;]:(&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; clazzs.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j == clazzs.length - <span class="hljs-number">1</span>)<br>                    System.out.print(clazzs[j].getName());<br>                <span class="hljs-keyword">else</span><br>                    System.out.print(clazzs[j].getName() + <span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;)&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反射的对象 User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br>  <span class="hljs-comment">//公有构造</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 私有构造</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> age</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">user1:User&#123;age=22, name=<span class="hljs-string">&#x27;hiway&#x27;</span>&#125;<br><span class="hljs-comment">#########################</span><br>user2:User&#123;age=25, name=<span class="hljs-string">&#x27;hiway2&#x27;</span>&#125;<br><span class="hljs-comment">#########################</span><br>构造函数[0]:private javaBase.User(int,java.lang.String)<br>参数类型[0]:(int,java.lang.String)<br>构造函数[1]:public javaBase.User(java.lang.String)<br>参数类型[1]:(java.lang.String)<br>构造函数[2]:public javaBase.User()<br>参数类型[2]:()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>反射</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAN:用于低资源条件下知识图谱补全的关系对抗网络</title>
    <link href="/2021/07/29/9.%E7%94%A8%E4%BA%8E%E4%BD%8E%E8%B5%84%E6%BA%90%E6%9D%A1%E4%BB%B6%E4%B8%8B%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8%E7%9A%84%E5%85%B3%E7%B3%BB%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/07/29/9.%E7%94%A8%E4%BA%8E%E4%BD%8E%E8%B5%84%E6%BA%90%E6%9D%A1%E4%BB%B6%E4%B8%8B%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8%E7%9A%84%E5%85%B3%E7%B3%BB%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<center style="font-size:30px">Relation Adversarial Network for Low Resource Knowledge Graph Completion</center><center>WWW 2020</center><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ol><li><p>本文首次将对抗性迁移学习应用于解决知识图完成的低资源问题（Low Resource Problem），主要针对的是链路预测和关系提取任务。</p></li><li><p>提出了关系对抗网络，利用关系鉴别器来区分来自不同关系的样本，然后学习从源关系到目标关系的持久性的特征。</p></li><li><p>提出了一种关系门控机制，充分放宽了共享标签空间的假设。该机制能够筛选出离群源关系/样本，缓解不相关关系/样本的负迁移，可以在端到端框架中进行训练。</p></li></ol><p>本文提出了一个<strong>加权关系对抗网络</strong>（Weighted Relation Adversarial Network，wRAN）的通用框架，该框架利用对抗过程，将从资源丰富的关系中学到的知识/特征，去适应不同但相关的低资源关系。wRAN框架综合考虑了三部分问题：<strong>对抗迁移学习</strong>（Adversarial Transfer Learning），核心思想是通过对抗性学习过程提取领域不变性特征，该过程能够减少源域和目标域之间的分布差异；<strong>关系对抗网络</strong>（Relation Adversarial Network），学习通用的关系不变性特征，以此弄清不同关系背后的语言变化因素，并缩小相关关系之间的语言差异；<strong>负迁移</strong>（Negative Transfer），区别于标准的domain adaption源域和目标域之间的标签空间完全相同且共享，wRAN考虑从多个源关系到一个或多个目标关系的适应，并且考虑了不同的关系可能对迁移产生不同的影响，离群的源关系在与目标关系做判别时可能导致负迁移。</p><p><img src="./img/20.1.png" style="width:1200px"></p><h3 id="负迁移"><a href="#负迁移" class="headerlink" title="负迁移"></a>负迁移</h3><p>如图中所示，RAN模型期望从三个源关系(place_of_death，place_of_birth和country)中学习一般的位置信息，然后将隐含知识适应于目标关系(place_of_burial)，以提高其预测性能。由于不同的关系可能对迁移产生不同的影响，并且在区分目标关系时存在可能导致负迁移的离群源关系。如图2所示，capital可能会导致向目标关系place_of_burial​的负迁移，因为其并不描述人与地方的关系。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="./img/20.2.png" style="width:1200px"></p><h3 id="实例编码机-Instance-Encoder"><a href="#实例编码机-Instance-Encoder" class="headerlink" title="实例编码机(Instance Encoder)"></a>实例编码机(Instance Encoder)</h3><p>实例编码机的作用是根据不同的任务类型，给定一个实体对或句子实例，利用神经网络将实例语义编码为一个向量。在本研究中，我们使用卷积神经网络(CNNs)来实现实例编码器，同时考虑了模型性能和时间效率。</p><p><img src="./img/20.3.png" style="width:600px"></p><p>我们将非线性变换$F(·)$​应用于$V$​的向量表示，得到一个特征向量$F = F(V;θ)$​。我们选择了两种卷积神经结构CNN和PCNN，将输入嵌入编码到实例嵌入中。还可以使用RNN等其他神经结构，以及ELMo和BERT等更复杂的方法。我们对这两个关系都采用非共享特征提取器，因为非共享提取器能够捕获更多关系特定的特征。本文通过学习源特征提取器$F_s$​和分类器$C$​来训练源鉴别模型$C(F_S(x;\theta))$​用于分类任务：</p><script type="math/tex; mode=display">\min _{F_{s}, C} \mathbb{L}_{s}=\mathbb{E}_{x, y \sim p_{s}(x, y)} L\left(C\left(F_{s}(x ; \theta)\right), y\right)</script><p>其中y是源数据的标签，$L(\cdot)$是分类器的损失函数。</p><h3 id="对抗关系适应-Adversarial-Relation-Adaptation"><a href="#对抗关系适应-Adversarial-Relation-Adaptation" class="headerlink" title="对抗关系适应(Adversarial Relation Adaptation)"></a>对抗关系适应(Adversarial Relation Adaptation)</h3><p>为了构建关系对抗网络RAN，我们采用了标准的对抗迁移学习框架，类似但不同的是，wRAN是一个两者对抗的对抗学习过程，其中第一个参与者是被训练来区分源关系和目标关系的关系鉴别器D，第二个参与者是特征提取器F，它同时被训练来混淆关系鉴别器，并希望学习从源到目标关系的共同特征。一般的想法是同时学习关系鉴别和关系不变的特征，其中源数据的标签预测器的损失最小，而关系鉴别器的损失最大。</p><script type="math/tex; mode=display">\begin{aligned}\min _{F_{s}, F_{t}} \max _{D} \mathbb{L}\left(D, F_{s}, F_{t}\right)=& \mathbb{E}_{x \sim p_{s}(x)}\left[\log D\left(F_{s}(x)\right)\right]+\\& \mathbb{E}_{x \sim p_{t}(x)}\left[1-\log D\left(F_{t}(x)\right)\right]\end{aligned}</script><p>其中$F_s$和$F_t$分别是源数据和目标数据的特征提取器，$D$表示的是二分类的关系鉴别器（对应GAN中的鉴别器，将所有源数据标签置为1，所以目标数据标签置为0）。</p><h3 id="加权关系适应-Weighted-Relation-Adaptation"><a href="#加权关系适应-Weighted-Relation-Adaptation" class="headerlink" title="加权关系适应(Weighted Relation Adaptation)"></a>加权关系适应(Weighted Relation Adaptation)</h3><p>我们提出了一种关系门机制来识别不相关的源关系/样本，并自动降低它们的权重，以解决负迁移问题。</p><h4 id="关系相关度-Relation-Correlation"><a href="#关系相关度-Relation-Correlation" class="headerlink" title="关系相关度(Relation Correlation)"></a>关系相关度(Relation Correlation)</h4><p>源分类器$C(F_s(x_i))$揭示了源关系空间$r_s$上的概率分布。这个分布很好地描述了分配$x_i$给每个$|r_s|$关系的概率。我们平均标签预测$\hat{y}_i = C(F_s(x_i)),x_i \in D_t$,在所有目标数据,因为它是可能的来源分类器可以在某个目标上犯一些错误数据和分配大概率为false关系甚至离群值的关系。每个源关系对训练的贡献的权重可以计算如下：</p><script type="math/tex; mode=display">w^{\text {relation }}=\frac{1}{n_{t}} \sum_{i=1}^{n_{t}} \hat{y}_{i}</script><p>$w^{\text {relation }}$是一个$|r_s|$维的用来量化每个不同的元关系的贡献度的权重向量。</p><h4 id="实例转移能力-Instance-Transfer-Ability"><a href="#实例转移能力-Instance-Transfer-Ability" class="headerlink" title="实例转移能力(Instance Transfer Ability)"></a>实例转移能力(Instance Transfer Ability)</h4><p>给定源目标关系的实例编码器，我们利用预先训练的辅助关系鉴别器进行实例权值学习。我们将辅助关系鉴别器最优参数的输出作为实例权值。其概念是，如果辅助关系鉴别器的激活量较大，则该鉴别器几乎可以正确地鉴别出样本与目标关系，这意味着样本很可能是不可转移的。实际上，在已知实例编码器学习到的$F_s$的情况下，通过优化$F_t(x)$和辅助关系鉴别器$D_a$，利用关系对抗损失来减少关系之间的移动:</p><script type="math/tex; mode=display">\begin{aligned}\min _{F_{t}} \max _{D_{a}} \mathbb{L}_{d}\left(D_{a}, F_{s}, F_{t}\right)=& \mathbb{E}_{x \sim p_{s}(x)}\left[\log D_{a}\left(F_{s}(x)\right)\right]+\\& \mathbb{E}_{x \sim p_{t}(x)}\left[1-\log D_{a}\left(F_{t}(x)\right)\right]\end{aligned}</script><p>为了避免退化解，我们用$F_s$的参数初始化$F_t$。辅助关系鉴别器由$D_a(f)=p(y=1|x)$给出，其中$x$是来自源和目标关系的输入。如果$D_a(f)\equiv 1$，那么样本很可能是不可转移的，因为它可以通过关系鉴别器几乎完全区别于目标分布。这些样本的贡献应该很小。因此，权值函数应该与$D_a(f)$成反比，定义源样本权值的一个自然方法是:</p><script type="math/tex; mode=display">w_{i}^{\text {instance }}=\frac{1}{\frac{D_{a}\left(F_{s}(x)\right)}{D_{a}\left(F_{t}(x)\right)}+1}=1-D_{a}(f)</script><h4 id="关系门机制-Relation-gate-Mechanism"><a href="#关系门机制-Relation-gate-Mechanism" class="headerlink" title="关系门机制(Relation-gate Mechanism)"></a>关系门机制(Relation-gate Mechanism)</h4><p>关系权重和实例权重都是有用的。但可以明显看出，不同粒度的权重对不同的目标关系有不同的贡献。一方面，对于源关系语义相似度较低的目标关系(如located_in)，加强关系权值有利于减少离群关系的负面影响。另一方面，对于具有许多语义上相似的源关系(如live_in、was_born_in)的目标关系(如educated_in)，很难区分不同源关系的影响，这表明有必要学习细粒度的实例权重。因此，对于标号为$y_j$​​​​的源关系中的实例，该实例的权值为:</p><script type="math/tex; mode=display">w_{i}^{\text {total }}=\alpha w_{i}^{\text {instance }}+(1-\alpha) w_{j}^{\text {relation }}</script><p>$w<em>{j}^{\text {relation }}$是向量$w^{\text {relation }}$第$j$个维度的值。然后使用$w</em>{i}^{t o t a l}=\frac{n<em>{s} w</em>{i}^{t o t a l}}{\sum<em>{i=1}^{n</em>{s}} w_{i}^{t o t a l}}$将权重标准化。其中$\alpha$是关系门用来平衡关系权重和实例权重的超参数。</p><script type="math/tex; mode=display">\alpha=\sigma\left(W_{r} F_{t}(x)\right)</script><p>其中$\sigma$是激活函数，$W_r$是权重矩阵。</p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><h4 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h4><script type="math/tex; mode=display">\begin{array}{l}\min _{F_{t}} \max _{D_{r}} \mathbb{L}_{w}\left(C, D_{r}, F_{s}, F_{t}\right)= \\\quad \mathbb{E}_{x \sim p_{s}(x)}\left[w^{t o t a l} \log D_{r}\left(F_{s}(x)\right)\right]+ \\\quad \mathbb{E}_{x \sim p_{t}(x)}\left[1-\log D_{r}\left(F_{t}(x)\right)\right]\end{array}</script><p>其中$D_r$​是关系对抗辨别器，其中权值$w^{total}$​是自动计算并分配给源关系数据的，以弱化关于部分自适应的离群关系和不可转移的实例，这可以减轻负迁移。整个培训过程如下所示。</p><p><img src="./img/20.4.png" style="width:600px"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="./img/20.5.png" style="width:600px"></p><p><img src="./img/20.6.png" style="width:1000px"></p>]]></content>
    
    
    <categories>
      
      <category>论文解读</category>
      
      <category>知识图谱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KGC</tag>
      
      <tag>Knowledge Graph</tag>
      
      <tag>Relation Extraction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FSRL:小样本知识图谱补全框架</title>
    <link href="/2021/07/16/8.%E5%B0%8F%E6%A0%B7%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8/"/>
    <url>/2021/07/16/8.%E5%B0%8F%E6%A0%B7%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<center style="font-size:30px">Few-Shot Knowledge Graph Completion</center><h2 id="模型FSRL"><a href="#模型FSRL" class="headerlink" title="模型FSRL"></a>模型FSRL</h2><p>主要由三部分组成：</p><p>（1）为每个实体通过邻居信息进行编码</p><p>（2）聚合每个关系的少量参考实体对信息</p><p>（3）将查询实体对(query entity pair)与参考集(reference set)进行匹配来进行关系预测</p><p><img src="./img/4.1.png"></p><h3 id="Encoding-Heterogeneous-Neighbors"><a href="#Encoding-Heterogeneous-Neighbors" class="headerlink" title="Encoding Heterogeneous Neighbors"></a>Encoding Heterogeneous Neighbors</h3><p><img src="./img/4.13.png"></p><p>通过引入注意力机制的模型，考虑实体邻居节点的不同影响力来编码实体h的表示：</p><p><img src="./img/4.3.png"></p><h3 id="Aggregating-Few-Shot-Reference-Set"><a href="#Aggregating-Few-Shot-Reference-Set" class="headerlink" title="Aggregating Few-Shot Reference Set"></a>Aggregating Few-Shot Reference Set</h3><p><img src="./img/4.14.png"></p><p>当前模型（例如GMatching）无法在参考集中模拟小样本实例的交互，这限制了模型的功能。 因此，我们需要设计一个模块，以有效地为每个关系r制定参考集$R<em>r$的聚合嵌入。 通过将邻居编码器应用于每个实体对$（h_k，t_k）∈R_r$，我们可以获得$（h_k，t_k）$的表示为$\mathcal{E}</em>{h<em>k,t_k} = [f</em>θ（h<em>k）⊕f</em>θ（t_k）]$。 学习具有很少拍摄的实体对的参考集$R_r$的表示形式具有挑战性，因为它需要对不同实体对之间的交互进行建模并积累其表达能力。 我们解决了这一难题并制定了$R_r$中所有实体对的聚合表示：</p><p><img src="./img/4.4.png"></p><p>$\mathcal{AG}$可以是池化操作，或者是前馈神经网络等，本文设计了一个具有良好性能的循环自动编码器：</p><p><img src="./img/4.5.png"></p><p><img src="./img/4.6.png"></p><p><img src="./img/4.7.png"></p><p>为了制定参考集reference set的嵌入，我们汇总了编码器的所有隐藏状态，并通过添加残差连接(residual connection)和注意力权重来扩展它们。 </p><p><img src="./img/4.8.png"></p><h3 id="Matching-Query-and-Reference-Set"><a href="#Matching-Query-and-Reference-Set" class="headerlink" title="Matching Query and Reference Set"></a>Matching Query and Reference Set</h3><p>本次训练步骤概括如下：</p><ol><li>采样少量实体对作为reference set</li><li>采样一些作为查询实体对query entity pair</li><li>将查询实体对替换尾节点作为反例</li><li>计算并更新匹配LSTM的参数</li></ol><p><img src="./img/4.15.png"></p><p><img src="./img/4.9.png"></p><p><img src="./img/4.11.png"></p><p><img src="./img/4.12.png"></p><p>在此处，$\mathcal L<em>{re}$将被合并到关系排名损失$\mathcal L</em>{rank}$中，以完善每个实体对的表示。其中γ是$L<em>{rank}$和$L</em>{re}$之间的权衡因子(trade-off factor)。 为了最小化L关节并优化模型参数，我们将每个关系作为一项任务，并设计了一个基于批采样的元训练程序。<img src="./img/4.10.png"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="./img/4.16.png"></p><p><img src="./img/4.17.png"></p>]]></content>
    
    
    <categories>
      
      <category>论文解读</category>
      
      <category>小样本知识图谱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Few-Shot Knowledge Graph</tag>
      
      <tag>KGC</tag>
      
      <tag>LSTM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RGHAT:基于多层注意力机制的知识图谱补全框架</title>
    <link href="/2021/07/14/7.%E9%80%9A%E8%BF%87%E5%A4%9A%E5%B1%82%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%B0%8F%E6%A0%B7%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8/"/>
    <url>/2021/07/14/7.%E9%80%9A%E8%BF%87%E5%A4%9A%E5%B1%82%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%B0%8F%E6%A0%B7%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<center style="font-size:30px">Relational Graph Neural Network with Hierarchical Attention for Knowledge Graph Completion</center><h2 id="问题-创新点"><a href="#问题-创新点" class="headerlink" title="问题/创新点"></a>问题/创新点</h2><p>知识图谱实体在嵌入时，并没有在局部上具体考虑某实体的neighborhood entity的分层级的、不同价值的信息对该实体的影响。</p><p>本文提出的Relational Graph Neural Network with Hierarchical Attention（RGHAT）框架里主要创新运用了两种注意力机制：</p><ol><li>第一层注意力机制是关系级注意力（考虑的是不同关系对中心实体的影响）</li><li>第二层注意力机制是实体级注意力（考虑的是相同关系的不同neighborhood实体对中心实体的影响）</li></ol><p>分层注意力机制使我们的模型更有效地利用实体的邻域信息。 </p><p><img src="./img/10.28 1.png" style="width:1200px"></p><p>通过对知识图谱进行上述分层表示，我们模型所基于的考虑(intuition)是：并非所有相邻关系都对表示中心实体同样重要，并且在每个$N_{h,r}$中，并非所有相邻实体在关系r相连的情况下表示中心实体方面同样重要。</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul><li>首先，与大多数现有的KGC模型不同，本文提出的模型非常具体地(explicitly)利用了每个实体的本地邻域信息。</li><li>其次，理解了可以将层次结构视为本地相邻信息的集成，并且已经验证了将相关信息集成到组(groups)中是有益的，可提供更多信息并在机器学习任务中产生更好的结果。</li><li>第三，在RGHAT中，分层注意力机制为模型提供了非常精细的(ﬁne-grained)学习过程，从而提高了模型的可解释性。 此外，在此设置下，可以以集体的(collective)方式训练具有相同关系的相邻三元组的权重，从而使我们的模型结果更稳定，更符合人类的直觉(intuition)。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型整体是一个encoder-decoder结构。</p><p>encoder首先将实体的本地邻域视为分层结构，然后计算该邻域的关系级注意力和实体级注意力。 接下来，将两个注意力得分合并为一个三级注意力得分，并将最终得分前馈给信息聚合器，后者可以将本地邻域信息有效地聚合到中心实体中。 最后，encoder将实体嵌入输出到decoder。 decoder是一个KGC模型，可以用许多现有的KGC模型代替。 此设置保证了我们模型的灵活性和可扩展性。 在本文中，作者选择ConvE模型作为decoder，因为它在本文进行的实验中表现最好。</p><p><img src="./img/10.28 2.png" style="width:1200px"></p><h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><h4 id="关系级别注意力-Relation-Level-Attention"><a href="#关系级别注意力-Relation-Level-Attention" class="headerlink" title="关系级别注意力(Relation-Level Attention)"></a>关系级别注意力(Relation-Level Attention)</h4><p>设定关系级别的注意力是因为不同关系的权重在表示实体方面存在很大差异。 例如，从直觉上讲，$Los\ Angeles\ Lakers，has_players$关系比$based_in_city$关系更具指示性，因为一个团队的球员可以唯一地标识该球队，而可能有多个基于该球队的球队在同一个城市。</p><p>在进行计算时，对中心需要表示的实体$e_1$本文将$(e_2,r,e_1)$转换为$(e_1,r^{-1},e_2)$进行计算。</p><p>对于实体$h$，在表示实体时，关系级别的注意力得分表示每个关系的权重，可以被定义为：</p><p><img src="./img/10.28 3.png" style="width:600px"></p><h4 id="实体级别注意力-Entity-Level-Attention"><a href="#实体级别注意力-Entity-Level-Attention" class="headerlink" title="实体级别注意力(Entity-Level Attention)"></a>实体级别注意力(Entity-Level Attention)</h4><p>实体级别的注意力机制，即相邻实体的对中心实体表示的权重也可能不同。 例如，关系中has_players将Los Angeles Lakers与其他球员联系起来，在所有这些球员中，当家球星可能比其他球员更能表示一支球队。</p><p>所提出的模型首先将处于同一关系下的相邻实体(neighborhood entity)视为一个组，然后计算实体级注意力，如下所示：</p><p><img src="./img/10.28 4.png" style="width:600px"></p><p>在上文两个级别的注意力得分都计算完毕之后，它们会被组合成一个三元组级的注意力得分：</p><p><img src="./img/10.28 5.png" style="width:600px"></p><p>其代表了三元组在表示中心实体$h$时三元组$(h,r,t)$的权重。</p><h4 id="信息聚合器-Information-Aggregator"><a href="#信息聚合器-Information-Aggregator" class="headerlink" title="信息聚合器(Information Aggregator)"></a>信息聚合器(Information Aggregator)</h4><p>信息聚合器将信息从本地邻域聚合到中央实体center entity，并获得实体h的基于邻域的表示形式，其表示为:</p><p><img src="./img/10.28 6.png" style="width:600px"></p><p>但是上述得到的表示$\hat h$还缺少了自身的有价值的信息（上述计算$a_{h,r}$只是满足注意力机制的输入需求? 只有很少一部分自身信息），为了更好的表示目标实体，下面进一步将基于邻域的表示和输入表示$h$组合，获得输出表示$h’$：</p><p><img src="./img/10.28 7.png" style="width:600px"></p><p>通过对图注意力网络的研究，本文也利用了多头注意力机制来稳定学习过程，提取有关领域的更多信息。</p><script type="math/tex; mode=display">\mathbf{h}^{\prime}=\|_{k=1}^{K} \mathbf{h}_{k}^{\prime}</script><p>其中$\mathbf{h}_{k}^{\prime}$是第$k$个头的表示输出。在encoder的最后一层，作者将多头的表示做了平均处理作为最后的输出：</p><script type="math/tex; mode=display">\mathbf{h}^{\prime}=\frac{1}{K} \sum_{k=1}^{K} \mathbf{h}_{k}^{\prime}</script><p>单层编码器在1次训练迭代中将one-hop的邻居实体的信息聚合到中央实体。 随着层数和迭代次数的增加，我们的模型可以有效地聚合来自多跳邻居的信息，这为表示中央实体提供了有价值的信息。 最终，编码器将嵌入h’的新实体输出到解码器。</p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>下图介绍了实验数据集的基本信息(实体种类，关系总类，训练集/验证集/测试集中三元组数量)</p><p><img src="./img/10.28 8.png" style="width:600px"></p><p><img src="./img/10.28 9.png" style="width:600px"></p><p><img src="./img/10.28 10.png" style="width:1000px"></p><p>最后作者其实还对单个实体的不同级别的注意力进行了细致的分析（下图分别是$Los\ Angeles\ Lakers和Tom\ Hanks$）：</p><p><img src="./img/10.28 11.png" style="width:800px"></p>]]></content>
    
    
    <categories>
      
      <category>论文解读</category>
      
      <category>知识图谱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KGC</tag>
      
      <tag>Knowledge Graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GMatching:一种小样本知识图谱补全框架</title>
    <link href="/2021/07/05/5.One-shot%20Relation%20Learning/"/>
    <url>/2021/07/05/5.One-shot%20Relation%20Learning/</url>
    
    <content type="html"><![CDATA[<center style="font-size:30px">One-Shot Relational Learning for Knowledge Graphs</center><h2 id="先导"><a href="#先导" class="headerlink" title="先导"></a>先导</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>知识图谱数据集往往呈长尾形态，很多关系只有几个三元组样本支撑。目前的知识图谱构建模型主要有两个问题：1.模型对于样本充足的关系和稀疏的长尾关系都同等对待，对样本量少的关系分类效果不好2.在关系表示层面，目前的模型对于新增关系无法进行预测。</p><p>为了预测目标关系，以前的方法通常依赖于对这些关系的充分学习后的表示（representation）。 在动态场景中，给定的训练实例很少，就无法对新关系的表示进行足够的训练，因此，对于当前模型，适应新关系的能力也受到限制。</p><p><img src="./img/2.1.png"></p><p>针对这些问题，本文提出了一种one-shot知识谱图关系学习框架，利用embedding-based的方法学习匹配度量函数，在新增关系或者长尾关系只有非常少量的训练数据的前提下也可以进行很好的预测，同时取得了不错的效果。</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ol><li>针对长尾关系的预测任务，转化为few-shot任务进行预测；</li><li>提出了一种应用于关系预测的one-shot learning框架GMatching，模型只依赖于实体embedding和图谱结构，学习匹配度量函数，利用预测三元组与参考三元组的相似度对新增关系进行预测，相比其他基于embedding的模型取得了更好地效果；</li><li>针对one-shot知识图谱补全任务，提出了2个不同量级的数据集。</li></ol><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="One-shot-Learning-Settings"><a href="#One-shot-Learning-Settings" class="headerlink" title="One-shot Learning Settings"></a>One-shot Learning Settings</h3><p>根据标准one-shot学习的设置，文章假设获取了training tasks。每个training tasks 都对应一个KG relation $r ∈ \mathcal{R}$, 并拥有training/testing triples: $\left{D<em>{r}^{t r a i n}, D</em>{r}^{t e s t}\right}$。这一tasks set就是 <strong><em>the meta-training set</em></strong>, $\large \mathbb{T}_{\text {meta}-\text {train}}$</p><p>根据one-shot的任务设定，在每个<script type="math/tex">D_{r}^{t r a i n}</script>中，采用一个三元组$\left(h<em>{0}, r,t</em>{0}\right)$。$D<em>{r}^{\text {test}}=\left{\left(h</em>{i}, r, t<em>{i}, \mathcal{C}</em>{h<em>{i}, r}\right)\right}$, 其中候选尾节点$\mathcal{C</em>{h<em>i,r}}={t</em>{ij}}$是在知识图谱$\mathcal{G}$中的实体集。给定test query$\left(h<em>{i}, r\right)$和 $D</em>{r}^{t r a i n}$中the labeled triple，可对the candidate set $\mathcal{C}<em>{h</em>{i}, r}$进行排列用来测试模型(metric model)。</p><p>The meta-training 的目标:</p><script type="math/tex; mode=display">\LARGE\min _{\theta} \mathbb{E}_{T_{r}}\left[\sum_{\left(h_{i}, r, t_{i}, \mathcal{C}_{h_{i}, r}\right) \in D_{r}^{t e s t}} \frac{\ell_{\theta}\left(h_{i}, r, t_{i} | \mathcal{C}_{h_{i}, r}, D_{r}^{t r a i n}\right)}{\left|D_{r}^{t e s t}\right|}\right]</script><p>$T<em>r$是meta-training set $\mathbb{T}</em>{\text { meta -train }}$, $\left|D<em>{r}^{t e s t}\right|$表示$D</em>{r}^{t e s t}$中的元组的个数。</p><p>$\ell<em>{\theta}(h_i,r,t_i|\mathcal{C}</em>{h_{i}, r})$表示 an arbitrary ranking-loss function, $\theta$表示模型的参数。</p><p>Loss function 表明在只从$D<em>{r}^{t r a i n}$中采样one-shot数据的条件下，衡量模型在$\left(h</em>{i}, r, t<em>{i}, \mathcal{C}</em>{h_{i}, r}\right)$上的性能。</p><p>训练完成后，就可以利用模型来预测新的关系$r^{\prime} \in \mathcal{R}^{\prime}$，这也就是 <strong><em>meta-testing</em></strong>。这些meta-testing relation 是meta-training中未出现的，即$\mathcal{R}^{\prime} \cap \mathcal{R}=\phi$,每一个meta-testing relation $r^{\prime}$ 也有one-shot training data $D<em>{r^{\prime}}^{t r a i n}$ 和testing data $D</em>{r^{\prime}}^{t e s t}$，其定义方式与meta-training一样。这些meta-testing relation形成了meta-test set  $\mathbb{T}_{\text {meta}-\text {test}}$。</p><p>文章还从 $\mathbb{T}<em>{\text { meta -train }}$中留出一小部分关系子集作为$$\mathbb{T}</em>{\text { meta- validation }}$$。构造验证集是为了不违反one-shot的假设。</p><p>最终，该方法获取了一个 <strong>background knowledge graph</strong> $\mathcal{G}^{\prime}$, 它是$\mathcal{G}$的一个子集，包含了除$\mathbb{T}<em>{\text { meta -train }}$、$\mathbb{T}</em>{\text { meta- validation }}$和$\mathbb{T}_{\text {meta}-\text {test}}$以外的所有关系。</p><p>本文主要是针对已知head entity和relation, 对tail entity进行补全的链路预测任务。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p><img src="./img/2.2.png"></p><h3 id="Neighbor-Encoder"><a href="#Neighbor-Encoder" class="headerlink" title="Neighbor Encoder"></a>Neighbor Encoder</h3><p>Neighbor Encoder的目标是学习三元组的实体向量表示。旨在增强每个实体在知识图谱中局部连接的表示。对于一个目标三元组中的实体Leonardo da Vinci，它的one-hop neighbors如2(a) 所示，每个neighbor都是以元组的形式出现, 以第k个neighbor为例$（r_k, e_k）$，由于他们出现在background KG中，所以已知他们的KG embedding为：</p><script type="math/tex; mode=display">\LARGE v_{r_k}=\mathrm{emb}(r_k),v_{e_k}=\mathrm{emb}(e_k)</script><p>Dropout方法？对于第k个元组之间的关系表示，即和neighbor之间的向量表示，本文采用了一个前馈网络：</p><script type="math/tex; mode=display">\LARGE C_{r_k,e_k}=W_c(v_{r_k}\oplus e_{r_k})+b_c</script><p>$C_{r_k,e_k}$就是关系-实体对$（r_k, e_k）$的特征表示，$W_c\in R^{d\times 2d}$和$b_c\in R^d$是需要学习的参数，$\oplus$是连接操作。</p><p>最后用所有neighbor的向量表示的平均向量来表示目标实体，即图中的Leonard da Vinci:</p><script type="math/tex; mode=display">\LARGE \begin{align}f(\mathcal{N}_e)&=\sigma(\frac{1}{|\mathcal{N}_e|} \sum_{(r_k, e_k)\in \mathcal{N}_e}C_{r_k,e_k})\\\mathcal{N}_e&=\{(r_k,e_k)|(e,r_k,e_k)\in \mathcal{G}'\}\end{align}</script><p>本文中我们设置激活函数为tanh，因为他在$\mathbb{T}_{meta-validation}$中取得了最好的表现。</p><h3 id="Matching-Processor"><a href="#Matching-Processor" class="headerlink" title="Matching Processor"></a>Matching Processor</h3><p>提取在neighbor encoder里生成的任意两对实体的向量表示，然后在两个实体对之间执行多步(multi-step)匹配，最后输出一个相似度得分。</p><p>首先选择一个依赖实体对(reference entity pair)，和一个询问实体对(query entity pair)，用上述方法编码，再拼接:</p><script type="math/tex; mode=display">\LARGE [f(\mathcal{N}_{h_0});f(\mathcal{N}_{t_0})],[f(\mathcal{N}_{h_i});f(\mathcal{N}_{t_{ij}})]</script><p>本文之前使用了cosine similarity度量函数，发现效果不好，作者就使用了LSTM-based Matching Processor来进行多步匹配。其中每一个过程步可以定义为:</p><script type="math/tex; mode=display">\LARGE\begin{align}h'_{k+1},c_{k+1}&=LSTM(q,[h_k\oplus s,c_k])\\h_k+1&=h'{k+1}+q\\score_{k+1}&=\frac{h_{k+1}\odot s}{\|h_{k+1}\|\|s\|}\end{align}</script><p><img src="./img/2.3.png"></p><p>其中，$L S T M ( x , [ h , c ] )$ 是一个具有输入为 $\mathcal{x}$、隐态 $\mathcal{h}$ 和单元态$\mathcal{c}$的标准LSTM。$s=f\left(\mathcal{N}<em>{h</em>{0}}\right) \oplus f\left(\mathcal{N}<em>{t</em>{0}}\right), q=f\left(\mathcal{N}<em>{h</em>{i}}\right) \oplus f\left(\mathcal{N}<em>{t</em>{i j}}\right)$分别是reference pair和 query pair的连接邻向量。K是一个待调的超参数，在K个step之后，采用score_k作为query enetity pair 与 support entity pair间最终相似度评分。</p><h3 id="Loss-Function-and-Training"><a href="#Loss-Function-and-Training" class="headerlink" title="Loss Function and Training"></a>Loss Function and Training</h3><p>对于一个query relation <strong><em>r</em></strong> 及其reference/training triple $\left(h<em>{0}, r, t</em>{0}\right)$, 本文收集了positive(true)query triplet $\left{\left(h<em>{i}, r, t</em>{i}^{+}\right) |\left(h<em>{i}, r, t</em>{i}^{+}\right) \in \mathcal{G}\right}$并通过填充尾部实体的方式构建了negative（false) query triplet { $\left{\left(h<em>{i}, r, t</em>{i}^{-}\right) |\left(h<em>{i}, r, t</em>{i}^{-}\right) \notin \mathcal{G}\right}$。于是模型可通过下式进行优化。</p><script type="math/tex; mode=display">\LARGE\ell_{\theta}=\max \left(0, \gamma+\operatorname{score}_{\theta}^{-}-\operatorname{score} _{\theta}^{+}\right)</script><p>其中，$\operatorname{score} <em>{\theta}^{+}$和 $\operatorname{score}</em>{\theta}^{-}$ 是利用metric model 比较the query triple$\left(h<em>{i}, r, t</em>{i}^{+} / t<em>{i}^{-}\right)$与 the reference triple$\left(h</em>{0}, r, t_{0}\right)$得到的标量。$\gamma$是一个待调的超参数。</p><p>在每次训练中，我们首先从meta-training set $\mathbb{T}_{meta-training}$中提出一个任务/关系 $T_r$, 然后在$T_r$里所有的已知三元组中，提取一个三元组作为reference/training 三元组$D_r^{train}$，提取另一批其他的三元组作为positive query/test 三元组 $D_r^{test}$. </p><p><img src="./img/2.4.png"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="./img/2.5.png"></p><p><img src="./img/2.6.png"></p><p>作者在本节对比了本文所提出的one-shot框架与KG embedding方法进行了对比实验。其中Baselines采用了监督学习方法，在训练过程中给测试关系一个标注样本，这样就可以学习到测试关系的表达并对其在测试阶段进行预测。对于作者提出的方法，分别采用了不同的KG embedding方法训练background KG中的实体和关系的向量表达，作为Neighbor Encoder的输入。从结果可以看出，本文提出的方法有着非常明显的优势。而且作者在Table 2的最后一行给出了仅提供Neighbor Encoder随机初始化的输入的情况下的表现，可见依旧取得了相对于Baselines的明显的提升。</p><h3 id="Neighbor-Encoder分析"><a href="#Neighbor-Encoder分析" class="headerlink" title="Neighbor Encoder分析"></a>Neighbor Encoder分析</h3><p>作者分析了在Neighbor Encoder中，采用的neighbors的数量阈值对实验结果的影响。由图可见，neighbors的数量越大，效果也有所提升，但效果的提升也逐渐趋于缓和。所以最终作者采用50作为neighbor的数量阈值。</p><p><img src="./img/2.7.png"></p>]]></content>
    
    
    <categories>
      
      <category>论文解读</category>
      
      <category>小样本知识图谱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Few-Shot Knowledge Graph</tag>
      
      <tag>KGC</tag>
      
      <tag>One-Shot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAGAT:基于自适应的注意力机制的KGC框架</title>
    <link href="/2021/07/05/6.RAGAT/"/>
    <url>/2021/07/05/6.RAGAT/</url>
    
    <content type="html"><![CDATA[<center style="font-size:30px">RAGAT: Relation Aware Graph Attention Network for Knowledge Graph Completion</center><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ol><li><p>本文提出了一种基于GAT的方法，即引入关系特定的网络参数，自适应地从不同关系下的相邻实体中学习信息。</p></li><li><p>作者在现有消息函数message function(Message Function: 解释为模型获取实体和关系之间交互的信息的方法, 具体查看下方表格)的基础上实现了与关系特定参数集成的RAGAT。此外，我们提出了一个新的消息函数来学习交互嵌入，其中提供了一个直观的解释。</p><p><img src="./img/19.6.png" style="width:500px"></p></li></ol><h2 id="RAGAT模型"><a href="#RAGAT模型" class="headerlink" title="RAGAT模型"></a>RAGAT模型</h2><p>模型整体框架如图所示：</p><ol><li>RAGAT首先将相同关系分组的实体嵌入和关系嵌入结合起来，生成关系-实体隐藏嵌入。然后，使用全图共享的权重矩阵将关系实体嵌入转换为消息(Message)。</li><li>采用具有不同学习网络参数的多头注意对消息进行聚合，使模型能够联合关注来自不同表示子空间的信息。在这两个阶段之后，可以更新每个实体的表示。</li></ol><p><img src="./img/19.2.png" style="width:500px"></p><p>其中给定的图，实体和关系的集合可以如下表示：</p><script type="math/tex; mode=display">\begin{array}{l}\mathcal{T}^{\prime}=\mathcal{T} \cup\left\{s, r, o^{-1} \mid(s, r, o) \in\{\mathcal{T}\}\right\} \cup\{s, \top, s \mid s \in \mathcal{E}\} \\\mathcal{R}^{\prime}=\mathcal{R} \cup \mathcal{R}_{i n v} \cup\{\top\}\end{array}</script><p>其中$\mathcal{R}_{\text {inv }}=\left{r^{-1} \mid r \in \mathcal{R}\right}$ and $\top$分别表示逆关系和自循环关系。</p><p>我们利用消息函数来表示如何从邻近节点和边学习信息。如果实体u与实体v通过关系r连接，那么它们的分布表示组合为</p><script type="math/tex; mode=display">\mathbf{c}_{(u, r, v)}=\phi\left(\mathbf{e}_{u}, \mathbf{e}_{r}, \mathbf{e}_{v}\right)</script><p>$\phi(\cdot)$用来将实体表示和关系表示进行组合。之后学习在整个图上共享的网络参数$\boldsymbol{\theta}_{g}$来生成消息message：</p><script type="math/tex; mode=display">\mathbf{m}_{(u, r, v)}=M\left(\mathbf{c}_{(u, r, v)}, \boldsymbol{\theta}_{g}\right)</script><p>这里消息函数生成的$\mathbf{m}<em>{(u, r, v)}$表示的就是从实体$u$到$v$传递的信息，其中$\boldsymbol{\theta}</em>{g}$在不同位置和局部结构上共享，可以过滤出不同拓扑结构上的共同特征。当实体与不同的关系相连时，它对中心实体$v$起不同的作用。根据这种推断，作者提出了关系感知图注意网络RAGAT。具体来说，RAGAT定义了用关系特定的网络参数$\boldsymbol{\theta}_{r}$参数化的关系感知消息函数，如下所示：</p><p><img src="./img/19.3.png" style="width:500px"></p><script type="math/tex; mode=display">\begin{aligned}\mathbf{c}_{(u, r, v)}^{r} &=\phi_{r}\left(\mathbf{e}_{u}, \mathbf{e}_{r}, \mathbf{e}_{v}, \boldsymbol{\theta}_{r}\right) \\\mathbf{m}_{(u, r, v)} &=M\left(\mathbf{c}_{(u, r, v)}^{r}, \boldsymbol{\theta}_{g}\right)\end{aligned}</script><p>其中$\boldsymbol{\theta}<em>{r}$用于提取关系特有特征。将相邻实体表示和关系表示分组，并送入不同的消息函数中。获得$\boldsymbol{\theta}</em>{r}$最直观的方法是为每个关系学习一个独立的权矩阵。考虑到采用不同的编码器和解码器进行实验，将$\boldsymbol{\theta}_{r}$限制为对角矩阵以降低计算复杂度:</p><script type="math/tex; mode=display">\boldsymbol{\theta}_{r}=\mathbf{W}_{r}=\operatorname{diag}\left(\mathbf{w}_{r}\right)</script><p>由于原始关系、逆关系和自循环关系是三种不同方向的边，我们为每一种边定义了单独的滤波器:</p><script type="math/tex; mode=display">\mathbf{m}_{(u, r, v)}=\mathbf{W}_{d i r(r)} \mathbf{c}_{(u, r, v)}^{r}</script><p>其中$\mathbf{W}<em>{d i r(r)} \in \mathbb{R}^{d</em>{1}} \times \mathbb{R}^{d_{0}}$定义如下：</p><script type="math/tex; mode=display">\mathbf{W}_{d i r(r)}=\left\{\begin{array}{ll}\mathbf{W}_{O} & \text { if } r \in \mathcal{R} \\\mathbf{W}_{I} & \text { if } r \in \mathcal{R}_{i n v} \\\mathbf{W}_{S} & \text { if } r \in\{T\}\end{array}\right.</script><h3 id="基于注意力机制的信息聚合器"><a href="#基于注意力机制的信息聚合器" class="headerlink" title="基于注意力机制的信息聚合器"></a>基于注意力机制的信息聚合器</h3><p>使用注意力机制对中心实体v的领域实体和关系进行聚合的方法如下：</p><script type="math/tex; mode=display">\mathbf{e}_{v}^{\prime}=f\left(\sum_{(u, r) \in \mathcal{N}(v)} \alpha_{u, r} \mathbf{m}_{(u, r, v)}\right)</script><p>其中f是一个非线性的激活函数。注意力系数$\alpha_{u, r}$定义为：</p><script type="math/tex; mode=display">\begin{aligned}\alpha_{u, r} &=\operatorname{softmax}\left(b_{u, r}\right) \\&=\frac{\exp \left(b_{u, r}\right)}{\sum_{i \in \mathcal{N}_{v}} \sum_{r \in \mathcal{R}_{i, u}} \exp \left(b_{i, r}\right)}\end{aligned}</script><p>本文的方法采用的注意力机制是一个由加权矩阵$\mathbf{W}<em>{a t t} \in \mathbb{R}^{1 \times d</em>{1}}$参数化并应用LeakyReLU非线性的单层前馈神经网络。</p><script type="math/tex; mode=display">b_{u, r}=\operatorname{LeakyReLU}\left(\mathbf{W}_{a t t} \mathbf{m}_{(u, r, v)}\right)</script><p>本文采用了多头注意，使模型能够联合关注来自不同关系参数子空间的信息。现在，最终嵌入注意头h中的信息计算为：</p><script type="math/tex; mode=display">\mathbf{m}_{(u, r, v)}^{h}=\mathbf{W}_{d i r(r)}^{h} \mathbf{c}_{r}^{h}</script><p>考虑到参数的大小，我们对M个独立注意头采用平均而不是串联的方法，从而得到实体v的输出表示如下：</p><script type="math/tex; mode=display">\mathbf{e}_{v}^{\prime}=f\left(\frac{1}{H} \sum_{h=1}^{H} \sum_{(u, r) \in \mathcal{N}_{v}} \alpha_{u, r}^{h} \mathbf{m}_{(u, r, v)}^{h}\right)</script><p>其中函数$f$代表$tanh$激活函数。此外，最后对关系嵌入进行了变换，使关系嵌入具有统一的嵌入大小为$\mathbf{e}_{v}^{\prime}$。</p><script type="math/tex; mode=display">\mathbf{e}_{r}^{\prime}=\mathbf{W}_{r e l} \mathbf{e}_{r}</script><p>其中$\mathbf{W}<em>{r e l} \in \mathbb{R}^{d</em>{1} \times d_{0}}$是一个可学习的权重矩阵，它将关系投射到相同的嵌入空间作为实体。</p><h3 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h3><p>可以在模型架构图中看出，本文使用了两种不同的解码器来验证模型的有效性，这两种解码器分别是ConvE和InteractE。给定一个三元组(s,r,o)，输入它的整体表示，解码器给这个三元组进行一个打分，计为$p(s,r,o)$，为训练该模型，对带标记平滑的标准交叉熵损失进行了优化：</p><script type="math/tex; mode=display">\mathcal{L}=-\frac{1}{N} \sum_{i}\left(t_{i} \cdot \log \left(p_{i}\right)+\left(1-t_{i}\right) \cdot \log \left(1-p_{i}\right)\right)</script><p>其中$t_i$表示三元组的标签，$p_i$就是相应的三元组得分。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="./img/19.4.png" style="width:600px"></p><p><img src="./img/19.5.png" style="width:1200px"></p>]]></content>
    
    
    <categories>
      
      <category>论文解读</category>
      
      <category>知识图谱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KGC</tag>
      
      <tag>Knowledge Graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NeurlIPS2020:基于GEN来进行图外链路预测任务</title>
    <link href="/2021/07/05/4.%E9%80%9A%E8%BF%87%E5%9B%BE%E5%A4%96%E6%8E%A8%E7%BD%91%E7%BB%9C(GEN)%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%A4%96%E9%93%BE%E8%B7%AF%E9%A2%84%E6%B5%8B/"/>
    <url>/2021/07/05/4.%E9%80%9A%E8%BF%87%E5%9B%BE%E5%A4%96%E6%8E%A8%E7%BD%91%E7%BB%9C(GEN)%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%A4%96%E9%93%BE%E8%B7%AF%E9%A2%84%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<center style="font-size:30px">Learning to Extrapolate Knowledge:Transductive Few-shot Out-of-Graph Link Prediction</center><center>NeurlIPS2020</center><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>本文主要介绍了图外(out-of-graph OOG)链接预测任务的图外推网络(GENs)。主要针对的问题是基于两点：1.动态变换的知识图谱 2.知识图谱中的长尾关系</p><p>在本文中，作者引入了一个具体的问题，就是不仅在已知实体和未知实体中预测链路，而且在未知实体之间也能进行链路预测的任务。作者提出了一个基于图外推网络的元学习框架通过任务的分布来进行OOG（图外）链路预测任务。</p><h3 id="元学习框架"><a href="#元学习框架" class="headerlink" title="元学习框架"></a>元学习框架</h3><p>假设我们有一个图$\mathcal{G} \subseteq \mathcal{E} \times \mathcal{R} \times \mathcal{E}$,由$e \in \mathcal{E}$和实体关系$r \in \mathcal{R}$ .那么,我们的学习目标是通过推断知识在给定图G,预测看见和看不见的实体之间的联系:$\left(e, r, e^{\prime}\right)$或$\left(e^{\prime}  , r, e\right)$，甚至在看不见的实体之间:$\left(e^{\prime}, r, e^{\prime}\right)$来表示一个分布为$p\left(\mathcal{E}^{\prime}\right)$的未知实体$e^{\prime} \in \mathcal{E}^{\prime}$,本文首先将给定图中的实体随机分割为模拟未知实体的元训练集和实际未知实体的元测试集。然后，在元训练过程中，通过采样模拟的未知实体集来生成一个任务，以便学习到的模型能够泛化到实际的未知实体。</p><p><img src="./img/18.1.png"></p><p>如果我们将已知实体和表示后的未知实体可视化，结果会如图所示：</p><p><img src="./img/18.2.png" style="width:400px"></p><p>形式上，每个以$p(\mathcal T)$为分布的任务$\mathcal T$都对应未知实体集合$\mathcal{E}<em>{\mathcal{T}} \subset \mathcal{E}^{\prime}$，并且预先定义这个集合的数量为$N$。然后将这些实体$e</em>{i}^{\prime} \in \mathcal{E}<em>{\mathcal{T}}$关联的三元组分为支持集和查询集：$\mathcal{T}=\bigcup</em>{i=1}^{N} \mathcal{S}<em>{i} \cup \mathcal{Q}</em>{i}$，此时$\mathcal{S}<em>{i}$和$\mathcal{Q}</em>{i}$定义如下：</p><script type="math/tex; mode=display">\mathcal{S}_{i}=\left\{\left(e_{i}^{\prime}, r_{j}, \tilde{e}_{j}\right) \text { or }\left(\tilde{e}_{j}, r_{j}, e_{i}^{\prime}\right)\right\}_{j=1}^{K} \text { and } \mathcal{Q}_{i}=\left\{\left(e_{i}^{\prime}, r_{j}, \tilde{e}_{j}\right) \text { or }\left(\tilde{e}_{j}, r_{j}, e_{i}^{\prime}\right)\right\}_{j=K+1}^{M_{i}} ; \tilde{e}_{j} \in\left(\mathcal{E} \cup \mathcal{E}^{\prime}\right)，</script><p>K是小样本学习的size，$M_i$是每个未知实体关联的三元组数量。我们的元学习目标是学习用一个支持集$\mathcal S$和一个元函数$f$来表示不可见的实体$\phi$，用一个分数函数来最大化查询集合上的三元组分数如下：</p><script type="math/tex; mode=display">\max _{\theta} \mathbb{E}_{\mathcal{T} \sim p(\mathcal{T})}\left[\frac{1}{N} \sum_{i=1}^{N} \frac{1}{\left|\mathcal{Q}_{i}\right|} \sum_{j=K+1}^{M_{i}} s\left(e_{i}^{\prime}, r_{j}, \tilde{e}_{j} ; \phi_{i}, \theta\right) \text { or } s\left(\tilde{e}_{j}, r_{j}, e_{i}^{\prime} ; \phi_{i}, \theta\right)\right], \phi_{i}=f_{\theta}\left(\mathcal{S}_{i}\right)</script><p>在本文中，我们引用这个特定的设置K样本的图外(OOG)链接预测。一旦用元训练任务$\mathcal{T}<em>{\text {train }}$对模型进行训练，我们就可以将其应用到未知的元测试任务$\mathcal{T}</em>{\text {test }}$，它的实体集与$\mathcal{T}_{\text {train }}$不相交。</p><p>模型训练单个任务$\mathcal T$时的示意图如下，其利用支持集S通过归纳(Inductive)和转导(Transductive)学习进行知识外推，然后预测与输出嵌入$\phi’$的链接：</p><p><img src="./img/18.4.png" style="width:400px"></p><h3 id="图外推网络"><a href="#图外推网络" class="headerlink" title="图外推网络"></a>图外推网络</h3><p>为了通过支持集$\mathcal{S}<em>{i}$将给定图$\mathcal{G}$的知识外推到不可见实体，我们提出了一种基于GNN的元学习机，输出未知实体的表示。（图中Inductive层）我们的元学习者$f</em>{\theta}(\cdot)$公式如下：</p><script type="math/tex; mode=display">f_{\theta}\left(\mathcal{S}_{i}\right)=\frac{1}{K} \sum_{(r, e) \in n\left(\mathcal{S}_{i}\right)} \mathbf{W}_{r} C_{r, e}</script><p>其中$n(\cdot)$是邻居实体和关系的集合:$n\left(\mathcal{S}<em>{i}\right)=\left{(r, e) \mid\left(e</em>{i}^{\prime}, r, e\right)\right.$ or $\left.\left(e, r, e<em>{i}^{\prime}\right) \in \mathcal{S}</em>{i}\right}$, K是集合中实体和邻居的数量，W是元学习的具体关系变换矩阵，$\mathbf C_{r, e}$是关系-实体对的表示的拼接。</p><h3 id="图外推网络上的元学习"><a href="#图外推网络上的元学习" class="headerlink" title="图外推网络上的元学习"></a>图外推网络上的元学习</h3><p>本文先前描述了归纳的GEN通过支持集$\mathcal S_i$构造每个未知实体的表示，然后在查询集$\mathcal Q_i$上独立地执行链接预测。这种归纳方案的一个主要缺点是它没有考虑未知实体之间的关系。然而，要将看不见的实体作为一个集合进行同时处理，我们不仅应该考虑已知实体和未知实体之间的关系，还应该考虑未知实体之间的关系。为了解决这个问题，我们扩展了归纳的GEN来进一步执行一个转导推理，这将允许知识在未知实体之间传播。（图中Transductive层）</p><script type="math/tex; mode=display">g_{\theta}\left(\mathcal{S}_{i}, \phi\right)=\frac{1}{K} \sum_{(r, e) \in n\left(\mathcal{S}_{i}\right)} \mathbf{W}_{r}^{\prime} C_{r, e}+\mathbf{W}_{0} \phi_{i}</script><p>其中$\mathbf{W}<em>{0} \in \mathbb{R}^{d \times d}$是一个用来关注嵌入$\phi_i$的自连接权重矩阵。为了利用邻域未知实体的知识，本文的Transductive层$g</em>{\theta}(\cdot)$用一个加权矩阵$\mathbf{W}_{r}’ \in \mathbb{R}^{d \times 2d}$聚集了所有邻域的表示，其中邻域可以包含未知实体的嵌入$\phi$，而不是像之前的归纳方案那样把它们当作噪声或者忽略它们为零向量。</p><h3 id="随机推断-Stochastic-Inference"><a href="#随机推断-Stochastic-Inference" class="headerlink" title="随机推断 Stochastic Inference"></a>随机推断 Stochastic Inference</h3><p>一个朴素的Transductive GEN通过在元训练中通过已知实体来模拟未知实体来概括未知实体。然而，由于每个实体只有几个三元体的少量OOG链接预测具有内在的不可靠性，因此在未知实体的表示上可能存在很高的不确定性。为了模拟这种不确定性，我们通过学习嵌入$\phi<em>{i}^{\prime}$在未知实体上的分布来随机编码未知实体。为此，我们首先假设真实后验分布有如下形式:$p\left(\phi</em>{i}^{\prime} \mid \mathcal{S}<em>{i}, \phi\right)$。因为计算真实的后验分布是棘手的,我们近似后使用$q\left(\phi</em>{i}^{\prime} \mid \mathcal{S}<em>{i}, \phi\right)=\mathcal{N}\left(\phi</em>{i}^{\prime} \mid \mu<em>{i}, \operatorname{diag}\left(\sigma</em>{i}^{2}\right)\right)$,然后通过两个transductive层计算均值和方差:$\mu<em>{i}=g</em>{\theta<em>{\mu}}\left(\mathcal{S}</em>{i}, \phi\right)$ 和 $\sigma<em>{i}=g</em>{\theta<em>{\sigma}}\left(\mathcal{S}</em>{i}, \phi\right)$。<em>最大化分数函数$s$的形式定义如下</em>：</p><script type="math/tex; mode=display">s\left(e_{h}, r, e_{t}\right)=\frac{1}{L} \sum_{l=1}^{L} s\left(e_{h}, r, e_{t} ; \phi^{\prime(l)}, \theta\right), \quad \phi^{\prime(l)} \sim q\left(\phi^{\prime} \mid \mathcal{S}, \phi\right)</script><p>为提高计算效率，作者在元训练meta-traning时将MC样本量设为L = 1。此外，我们在元测试meta-test时使用足够大的样本量(例如L = 10)进行MC近似(MC approximation)。然后，我们的最终GEN通过随机推理训练Inductive和Transductive步骤。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>每个任务$\mathcal T$对应一组未知实体$\mathcal{E}<em>{\mathcal{T}} \subset \mathcal{E}^{\prime}$，包含了一个支持集和一个查询集组成:$\mathcal{T}={\mathcal{S}, \mathcal{Q}}$。在训练过程中，我们使用支持集$\mathcal S$来表示未知实体$e</em>{i}^{\prime} \in \mathcal{E}<em>{\mathcal{T}}$的嵌入。然后，在测试时，我们使用正样本的查询集$\mathcal{Q}</em>{i}$来优化我们的GEN。由于每个查询集只包含正采样的三元组，我们执行负采样，通过允许元学习者区分正三元组和负三元组来更新元学习者。具体来说，我们替换查询集中每个三元组的实体:$\mathcal{Q}<em>{i}^{-}=\left{\left(e</em>{i}^{\prime}, r, e^{-}\right)\right.$ or $\left.\left(e^{-}, r, e_{i}^{\prime}\right) \mid e^{-} \in \mathcal{E}\right}$，其中$e^-$为负采样的实体。然后我们使用铰链损失优化我们的模型如下：</p><script type="math/tex; mode=display">\mathcal{L}\left(\mathcal{Q}_{i}\right)=\sum_{\left(e_{h}, r, e_{t}\right) \in \mathcal{Q}_{i}} \sum_{\left(e_{h}, r, e_{t}\right)^{-} \in \mathcal{Q}_{i}^{-}} \max \left\{\gamma-s^{+}\left(e_{h}, r, e_{t}\right)+s^{-}\left(e_{h}, r, e_{t}\right)^{-}, 0\right\}</script><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p><img src="./img/18.3.png" style="width:600px"></p><p>上述的三元组打分函数可以用如下几种方式实现：</p><p><img src="./img/18.8.png" style="width:600px"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="./img/18.5.png"></p><p><img src="./img/18.7.png" style="width:600px"></p>]]></content>
    
    
    <categories>
      
      <category>论文解读</category>
      
      <category>小样本知识图谱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Few-Shot Knowledge Graph</tag>
      
      <tag>KGC</tag>
      
      <tag>Out-Of-Graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SIGIR2021:通过门控注意力邻域聚合器进行FKGC</title>
    <link href="/2021/05/29/3.%E9%80%9A%E8%BF%87%E9%97%A8%E6%8E%A7%E6%B3%A8%E6%84%8F%E5%8A%9B%E9%A2%86%E5%9F%9F%E8%81%9A%E5%90%88%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%B0%8F%E6%A0%B7%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8/"/>
    <url>/2021/05/29/3.%E9%80%9A%E8%BF%87%E9%97%A8%E6%8E%A7%E6%B3%A8%E6%84%8F%E5%8A%9B%E9%A2%86%E5%9F%9F%E8%81%9A%E5%90%88%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%B0%8F%E6%A0%B7%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<center style="font-size:30px">Relational Learning with Gated and Attentive Neighbor Aggregator for Few-Shot Knowledge Graph Completion</center><center>SIGIR 2021</center><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p><img src="./img/17.9.png" style="width:50%"></p><p>如图，红色线表示小样本关系（few-shot relation），绿色的边缘代表邻居关系。根据实例，本文提出了两个challenge：</p><ol><li>对于小样本关系<em>Pole Position</em>，头部实体只有一个邻居并且无法表示关系<em>Pole Position</em>。因此，稀疏的领域会带来噪声。从而无法表示小样本关系。（稀疏领域）</li><li>小样本关系<em>Pole Position</em>是N-1的关系。由于特定于N-1关系的头部实体的不确定性，所以预测头部实体的结果不会特别准确。 （复杂关系）</li></ol><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul><li>提出了门控注意力邻居聚合器来捕获小样本关系中最有价值的上下文语义。</li><li>首先将MAML和TransH结合起来进行小样本知识图谱补全，提出的模型也能同时考虑到1-N，N-1和N-N的复杂关系</li><li>在设定的数据集上取得了良好的效果。</li></ul><h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><p><img src="./img/17.1.png" style="width:80%"></p><p>我们首先根据提出的两阶段表示学习机制学习支持集上三元组的小样本关系表示(few-shot relation representation)，然后通过查询集中的三元组优化整个模型。 </p><h3 id="Global-Stage-General-Representation"><a href="#Global-Stage-General-Representation" class="headerlink" title="Global Stage: General Representation"></a>Global Stage: General Representation</h3><h4 id="Gated-and-Attentive-Neighbor-Aggregator"><a href="#Gated-and-Attentive-Neighbor-Aggregator" class="headerlink" title="Gated and Attentive Neighbor Aggregator"></a>Gated and Attentive Neighbor Aggregator</h4><p><img src="./img/17.2.png" style="width:30%"></p><p>这部分是受图注意力网络（GAT）的启发，用来捕获单个实体的不同邻居实体对其的影响，来提高实体编码的质量。对实体e的关系和邻居节点$(r_i,e_i)\in N_e$获取注意力值如下：</p><script type="math/tex; mode=display">\begin{aligned}\mathbf{c}_{i} &=\mathbf{W}_{1}\left[\mathbf{r}_{i} ; \mathbf{e}_{i}\right] \\d_{i} &=\text { LeakyReLU} \left(\mathbf{U}_{1}^{\top} \mathbf{c}_{i}\right)\end{aligned}</script><p>$\mathbf{W}<em>{1}$是线性变换矩阵，$\mathbf{U}</em>{1}$是权重矩阵然后通过LeakyReLU激活函数获得不同邻居的注意力值。然后使用softmax函数将获取到的注意力值和每个邻居都联系起来：</p><script type="math/tex; mode=display">\alpha_{i}=\operatorname{softmax}\left(d_{i}\right)=\frac{\exp \left(d_{i}\right)}{\sum\left(r_{i}, e_{i}\right) \in \mathcal{N}_{e} \exp \left(d_{i}\right)}</script><p>为了消除在表示小样本关系时，由于稀疏邻域导致的噪声邻居实体的影响，作者采用了门值g来自动确定激活实体e的邻居实体的程度（degree）：</p><script type="math/tex; mode=display">g=\text { sigmoid }\left(\mathbf{U}_{2}^{\top} \sum_{\left(r_{i}, e_{i}\right) \in \mathcal{N}_{e}} \alpha_{i} \mathbf{c}_{i}+b_{g}\right)</script><p>基于门控机制，通过组合头部或尾部实体e的邻域表示及其实体嵌入来获得小样本关系r的一半邻域的表示（指代为h’或t’）：</p><script type="math/tex; mode=display">\mathbf{e}^{\prime}=\sigma\left(\sum_{\left(r_{i}, e_{i}\right) \in N_{e}} g \alpha_{i} \mathbf{c}_{i}+(1-g) \mathbf{W}_{2} \mathbf{e}+\mathbf{b}\right)</script><p>$\mathbf{W}_2$表示权重矩阵，$\mathbf{b}$是偏置的矢量参数。 获得h’和t’之后，通过拼接操作获得领域表示s：$\mathbf{s}=\left[\mathbf{h}^{\prime} ; \mathbf{t}^{\prime}\right]$</p><h4 id="Generating-the-Few-shot-Relation-Representation"><a href="#Generating-the-Few-shot-Relation-Representation" class="headerlink" title="Generating the Few-shot Relation Representation"></a>Generating the Few-shot Relation Representation</h4><blockquote><p>MetaR通过仅对支持集中所有实体对的关系元取平均来表示小样本关系，而在表示一种小样本关系时忽略了支持集中所有实体对的不同影响。 </p></blockquote><p>本文引入了一种注意力机制的Bi-LSTM编码器，用于在支持集中集成一种小样本关系的多个邻域表示，可用于学习一种小样本关系的一般表示。</p><p><img src="./img/17.3.png" style="width:30%"></p><p> 具体地，从等式导出邻域表示。依次将上个环节中的领域表示$\mathbf{s}_{i}^{K}$送入注意力机制的Bi-LSTM中，其中𝐾是支持集的大小。 双向Bi-LSTM的正向和反向隐状态的计算方式如下：</p><script type="math/tex; mode=display">\begin{aligned}\overrightarrow{\mathbf{p}}_{i} &=\operatorname{LSTM}\left(W_{h 1} \overrightarrow{\mathbf{p}}_{i-1}+W_{s 1} \overrightarrow{\mathbf{s}}_{i}\right) \\\overleftarrow{\mathbf{p}}_{i} &=\operatorname{LSTM}\left(W_{h 2} \overleftarrow{\mathbf{p}}_{i-1}+W_{s 2} \overleftarrow{\mathbf{s}}_{i}\right)\end{aligned}</script><p>最终的隐状态可以通过两个方向隐状态拼接再做一个线性变换得到：</p><script type="math/tex; mode=display">\begin{array}{l}\mathbf{p}_{i}=\left[\overrightarrow{\mathbf{p}}_{i} ; \overleftarrow{\mathbf{p}}_{i}\right] \\\mathbf{p}_{i}^{\prime}=\mathbf{W}_{3} \mathbf{p}_{i}\end{array}</script><p>然后再使用注意力机制计算各个隐状态的权重：</p><script type="math/tex; mode=display">\begin{aligned}o_{i} &=\tanh \left(\mathbf{U}_{3}^{\top} \mathbf{p}_{i}^{\prime}+b_{a}\right) \\\beta_{i} &=\operatorname{softmax}\left(o_{i}\right)=\frac{\exp \left(o_{i}\right)}{\sum_{i=1}^{K} \exp \left(o_{i}\right)}\end{aligned}</script><p>最后通过整合支持集中来自𝐾个三元组的所有邻域表示来表示小样本关系的一般表示r’。 得到Bi-LSTM的最后隐状态：</p><script type="math/tex; mode=display">\mathbf{r}^{\prime}=\sum_{i=1}^{K} \beta_{i} \mathbf{p}_{i}^{\prime}</script><h3 id="Local-Stage-MTransH"><a href="#Local-Stage-MTransH" class="headerlink" title="Local Stage: MTransH"></a>Local Stage: MTransH</h3><p>本文旨在考虑1-N、N-1和N-N的复杂关系的同时，更新局部阶段小样本关系的表示。</p><p><img src="./img/17.4.png" style="width:50%"></p><p>transH模型示意图如下：</p><p><img src="./img/17.10.png" style="width:30%"></p><p>受典型的KGE模型TransH的启发，该模型可以建模复杂的关系，三元组$(h_i,r,t_i)$的分数函数定义为：</p><script type="math/tex; mode=display">\begin{array}{l}\mathbf{h}_{p i}=\mathbf{h}_{i}-\mathbf{h}_{i} \mathbf{P}_{r} \mathbf{h}_{i}, \mathbf{t}_{p i}=\mathbf{t}_{i}-\mathbf{t}_{i} \mathbf{P}_{r} \mathbf{t}_{i} \\E\left(h_{i}, r, t_{i}\right)=\left\|\mathbf{h}_{p i}+\mathbf{r}^{\prime}-\mathbf{t}_{p i}\right\|_{L 1 / L 2}\end{array}</script><p>其中$h_i$和$t_i$是在预训练中学习到的头部和尾部嵌入。 $P_r$是关于𝑟的超平面的法向量。 r’是从等式推导的小样本关系的一般表示。这部分得到一个损失函数如下：</p><script type="math/tex; mode=display">L\left(S_{r}\right)=\sum_{\left(h_{i}, r, t_{i}\right) \in S_{r}} \sum_{\left(h_{i}, r, t_{i}^{\prime}\right) \in S_{r}^{\prime}} \max \left[0, E\left(h_{i}, r_{i}, t_{i}\right)+\gamma-E\left(h_{i}, r_{i}, t_{i}^{\prime}\right)\right]</script><p>然后计算r’的梯度：</p><script type="math/tex; mode=display">\operatorname{Grad}\left(r^{\prime}\right)=\frac{\mathrm{d} L\left(S_{r}\right)}{\mathrm{d} r^{\prime}}</script><p>然后通过学习率为$l$的随机梯度下降更新：</p><script type="math/tex; mode=display">r_{m}=r^{\prime}-l_{r} G r a d\left(r^{\prime}\right)</script><p>通过模型无关元学习(model agnostic meta learning—MAML)方法能够学习每个小样本关系的超平面参数$P<em>r$。对于任务$T_r$上的超平面参数$P_r$，当适应新任务$T</em>{r’}$时，超平面参数变为$P’_{r}$。 在MAML之后，更新的参数是由当前任务$S_r$的支持集上的一个（或某些）梯度下降更新来计算的。 例如，参数$P_r$可以通过单个梯度步骤以学习速率𝑙进行更新，如下所示： </p><script type="math/tex; mode=display">\mathbf{P}_{r}^{\prime}=\mathbf{P}_{r}^{*}-l_{p} \frac{\mathrm{d} L\left(S_{r}\right)}{\mathrm{d} \mathbf{P}_{r}}</script><p>当我们在当前任务上获得更新的关系表示和超平面参数时，会将它们传输到查询集(Query Set)中的实例。 </p><p><img src="./img/17.5.png" style="width:50%"></p><p>采用和支持集上相同的方式，可以通过以下方式获得查询集的得分和损失： </p><script type="math/tex; mode=display">\begin{array}{l}\mathbf{h}_{p j}=\mathbf{h}_{j}-\mathbf{h}_{j} \mathbf{P}_{r m} \mathbf{h}_{j}, \mathbf{t}_{p j}=\mathbf{t}_{j}-\mathbf{t}_{j} \mathbf{P}_{r m} \mathbf{t}_{j}\\E\left(h_{j}, r, t_{j}\right)=\left\|\mathbf{h}_{p j}+\mathbf{r}_{m}-\mathbf{t}_{p j}\right\|_{L 1 / L 2}\\L\left(Q_{r}\right)=\sum_{\left(h_{j}, r, t_{j}\right) \in Q_{r}} \sum_{\left(h_{j}, r, t_{j}^{\prime}\right) \in Q_{r}^{\prime}} \max \left[0, E(h, r, t)+\gamma\\-E\left(h, r, t^{\prime}\right)\right]\end{array}</script><p>此外，我们可以在任务𝑇的查询集上评估更新的超平面参数$P’_r$。 同时，初始化良好的超平面参数$P^*_r$可以计算如下： </p><script type="math/tex; mode=display">\mathbf{P}_{r}^{*}=\mathbf{P}_{r}-l_{p} \frac{\mathrm{d} L\left(Q_{r}\right)}{\mathrm{d} \mathbf{P}_{r}^{\prime}}</script><h3 id="训练流程"><a href="#训练流程" class="headerlink" title="训练流程"></a>训练流程</h3><p><img src="./img/17.6.png" style="width:50%"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><img src="./img/17.7.png" style="width:60%"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="./img/17.8.png" style="width:70%"></p>]]></content>
    
    
    <categories>
      
      <category>论文解读</category>
      
      <category>小样本知识图谱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Few-Shot Knowledge Graph</tag>
      
      <tag>KGC</tag>
      
      <tag>TransH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SIGIR2021:增量时序知识图谱补全框架TIE</title>
    <link href="/2021/05/27/2.%E5%A2%9E%E9%87%8F%E6%97%B6%E5%BA%8F%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8%E6%A1%86%E6%9E%B6TIE/"/>
    <url>/2021/05/27/2.%E5%A2%9E%E9%87%8F%E6%97%B6%E5%BA%8F%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8%E6%A1%86%E6%9E%B6TIE/</url>
    
    <content type="html"><![CDATA[<center style="font-size:30px">TIE: A Framework for Embedding-based Incremental Temporal Knowledge Graph Completion</center><center>SIGIR 2021</center><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ol><li>本文引入了一项新任务，即增量TKGC，并提出了TIE框架，这是一种将增量学习与TKGC集成在一起的训练和评估框架。</li><li>提出了新的评估指标，分别是Deleted Facts Hits@10 (DF)和Reciprocal Rank Difference Measure (RRD)</li><li>提出了TKG迭代训练中，使用新增的fact进行微调训练，有效的减少了训练的数据集大小，并且显著提高了训练速度。</li></ol><h2 id="TKGC任务设定"><a href="#TKGC任务设定" class="headerlink" title="TKGC任务设定"></a>TKGC任务设定</h2><p>在本文，作者分析对比了标准的TKGC任务和引入的增量TKGC任务的区别。主要体现在：</p><ol><li>输入的范围：在标准的TKGC任务的训练中，训练和评估都在时间步1到T中每步进行一次，在增量的TKGC任务中，每个时间步仅使用新增的数据进行训练和评估。</li><li>用于评估模型的数据的时间步范围：在标准的TKGC任务的训练中，模型将${D^1,…,D^T}$作为输入，并回答${D^1<em>{test},…,D^T</em>{test}}$中的查询；增量的TKGC任务的训练中，模型将${D^1,…,D^t}$作为输入，并回答${D^1<em>{test},…,D^t</em>{test}}$中的查询。</li><li>得分函数产生最终排名的候选实体集：标准TKGC是所有实体集（$E=\bigcup<em>{i=1}^{T} E^{i} $）；增量TKGC是已知的实体集（$E</em>{k n o w n}^{t}=\bigcup_{i=1}^t E^{i}$）</li></ol><h2 id="度量方式"><a href="#度量方式" class="headerlink" title="度量方式"></a>度量方式</h2><h3 id="标准TKGC的度量方式"><a href="#标准TKGC的度量方式" class="headerlink" title="标准TKGC的度量方式"></a>标准TKGC的度量方式</h3><p>一般使用Hit@k和Mean Reciprocal Rank (MRR)的方式来对标准TKGC的效果进行评估。其中Hit@10的公式定义如下：</p><script type="math/tex; mode=display">\frac{1}{\left|D_{\text {test }}^{t}\right|} \sum_{(s, r, o, t) \in D_{\text {test }}^{t}} I(\operatorname{rank}(o \mid s, r, t) \leq 10)</script><h3 id="增量TKGC的度量方式"><a href="#增量TKGC的度量方式" class="headerlink" title="增量TKGC的度量方式"></a>增量TKGC的度量方式</h3><p>既然我们已经知道增量TKGC的目的就是从过去的时间步骤中去吸收知识，所以一个增量学习的方法应该基于他在当前和历史两个不同时间段的四元组预测的表现来评估。</p><p>Current and Historical Average Measure（当前和历史平均度量）其实就是用当前的模型，用当前和历史的$D_{test}$去评估模型，求平均值。</p><p>Intransigence Measure（顽固性度量）度量算法无法识别在历史阶段是成立，但是在当前阶段却是不成立的事实。比如一个学生从学校毕业了，那么他就不再和这个学校有联系了。</p><p>将顽固性度量具体化到模型的能力中可以分为以下两个方面：</p><ol><li>为已删除的事实分配低RANK</li><li>将当前有效的事实排在已删除的事实之上</li></ol><p>根据以上两个特性，本文提出了Deleted Facts Hits@10 (DF 删除事实Hit@10)和Reciprocal Rank Difference (RRD 相互排名差异) </p><script type="math/tex; mode=display">\mathrm{DF}_{t} \triangleq \frac{1}{Z_{t}} \sum_{(s, r, o, t) \in D_{t e s t}^{t}} \sum_{o^{\prime} \in O_{s, r, t}^{\prime}} I\left(\operatorname{rank}\left(o^{\prime} \mid s, r, t\right) \leq k\right)\\\mathrm{RRD}_{t} \triangleq \frac{100}{Z_{t}} \sum_{(s, r, o, t) \in D_{t e s t}^{t}} \sum_{o^{\prime} \in O_{s, r, t}^{\prime}}\left(\frac{1}{\operatorname{rank}(o \mid s, r, t)}-\frac{1}{\operatorname{rank}\left(o^{\prime} \mid s, r, t\right)}\right)</script><p>$O_{s, r, t}^{\prime}$是负对象negative objects，$Z_t$是归一化常数：</p><script type="math/tex; mode=display">\begin{array}{c}O_{s, r, t}^{\prime}=\left\{o^{\prime} \mid \exists t^{\prime} \in\left\{t-\tau_{d} \ldots t-1\right\}, \exists o^{\prime} \in E_{k n o w n}^{t^{\prime}},\left(s, r, o^{\prime}, t^{\prime}\right) \in D^{t^{\prime}}\right\}, \\Z_{t}=\sum_{(s, r, o, t) \in D_{t e s t}^{t}}\left|O_{s, r, t}^{\prime}\right|\end{array}</script><h2 id="TIE框架"><a href="#TIE框架" class="headerlink" title="TIE框架"></a>TIE框架</h2><p><img src='./img/16.1.png'></p><p>一句话概括：使用增量学习方法，用来解决模型顽固性和历史知识过遗忘的缺点的高效的编码-解码结构的TKGC框架。其中，该框架使用Experience Replay经验重播和Temporal Regularization时间正则化技术来解决使用TKG表示学习模型来微调的方法的过度遗忘特性。除此之外，本文也提出了使用已删除的事实作为负训练的样本来解决模型顽固性的问题。最后，本文作者建议每个时间步时仅使用新添加的事实进行微调，因为TKG中模型最感兴趣的事实主要由持久性的事实组成，即只要事实的平均变化时间通常足够长，以至于相邻时间步长之间这个事实也不会产生剧烈的变化。</p><h3 id="Experience-Replay"><a href="#Experience-Replay" class="headerlink" title="Experience Replay"></a>Experience Replay</h3><p>经验重播需要定义一个滑动窗口作为缓冲区$B^t$，包含历史的k个时间段的TKG数据，用这个k个时间段和当前TKG上的全部四元组来训练模型。</p><h4 id="Replay-Fact-Sampling重播事实采样"><a href="#Replay-Fact-Sampling重播事实采样" class="headerlink" title="Replay Fact Sampling重播事实采样"></a>Replay Fact Sampling重播事实采样</h4><p>选择下列两种方案，从$B^t$中提取正样本$P^t$。</p><ol><li><p>Uniform Sampling 统一采样三元组</p></li><li><p>Frequency-based Sampling 基于历史模式频率HPF和当前模式频率CPF来采样。需要去匹配的模式Pattern定义如下：（其中*可以代表任意实体）</p></li></ol><script type="math/tex; mode=display">P=\{(s, r, o),(s, *, o),(s, r, *),(*, r, o),(s, *, o),(s, *, *),(*, *, o)\} .</script><p>举例，如果要求模式$(s,*,o)$的HPF和CPF，如下：</p><script type="math/tex; mode=display">\begin{aligned}h_{s, *, o}^{t}=&\left|\left\{\left(s, r^{\prime}, o, t^{\prime}\right) \mid \exists r^{\prime}, t^{\prime},\left(s, r^{\prime}, o, t^{\prime}\right) \in B^{t}\right\}\right| \\c_{s, *, o}^{t} &=\left|\left\{\left(s, r^{\prime}, o, t\right) \mid \exists r^{\prime},\left(s, r^{\prime}, o, t\right) \in D^{t}\right\}\right|\end{aligned}</script><p>B中每个四元组的采样概率设计两个概念：频率相关概率$fp(s,r,o)$和时间相关概率$tp(t’)$，本文定义如下：</p><script type="math/tex; mode=display">f p(s, r, o)=\sum_{p \in P} \lambda_{p}\left[\log \left(h_{p}^{t}+1\right)+\gamma \tau \log \left(c_{p}^{t}+1\right)\right]</script><p>标量值𝜆表示与模式𝑝的频率相关的权重。𝜏是窗口的长度。另外引入𝛾作为控制$h^t<em>{p}$和$c^t</em>{p}$比重的参数。采用对数形式的频率计算公式主要是用来缩小具有特别大频率的模式的比例，以避免在同一种模式下重复采样过多的四元组。</p><p>$tp(t’)$代表距离当前时间步长t不同时间的指数衰减函数，用</p><script type="math/tex; mode=display">t p\left(t^{\prime}\right)=\exp \left(\frac{t’-t}{\sigma}\right),</script><p>来表示，其中$\sigma$是控制函数平滑度的标量。最后更具这两个概率结合得到的非归一化采样率$s(s,r,o,t’)$就等于$fp(s,r,o)tp(t’)$。</p><p>使用这种方式虽然可以对具有更高模式频率的四元组进行采样，但是在某些情况下，某些代表性高的四元组却有可能会因为匹配的模式低而没有被采样。这时候作者又提出了一种逆模式采样的方案，来鼓励采样较低模式频率的四元组:</p><script type="math/tex; mode=display">\frac{t p\left(t^{\prime}\right)}{f p(s, r, o)}</script><p>在计算完所有四元组的采样率之后，我们将每个四元组的采样概率归一化，并使用它们采样获得$P^t$。</p><p><img src='./img/16.2.png' style='width:60%'></p><h3 id="Representation-Learning表示学习"><a href="#Representation-Learning表示学习" class="headerlink" title="Representation Learning表示学习"></a>Representation Learning表示学习</h3><p>通过下列方式，在$P^t$中使用依赖于时间的负采样策略收集负实体集（negative entities set）：</p><script type="math/tex; mode=display">D_{s, r, t^{\prime}}^{-}=\left\{o^{\prime} \mid o^{\prime} \in E_{k n o w n^{\prime}}^{t^{\prime}}\left(s, r, o^{\prime}, t^{\prime}\right) \notin D^{t^{\prime}}\right\}</script><p>本文还使用了知识蒸馏损失来确保在新的当前学习步骤中不会丢失先前学习到的判别信息。在学习t时间的参数之前，模型存储前t-1个时间步的输出网络的参数如下：</p><script type="math/tex; mode=display">q_{s, r, o, t^{\prime}}^{t-1}=\frac{\exp \left(\phi^{t-1}\left(s, r, o, t^{\prime}\right)\right)}{\sum_{o^{\prime} \in D_{s, r, t^{\prime}}^{-}} \exp \left(\phi^{t-1}\left(s, r, o^{\prime}, t^{\prime}\right)\right)}</script><p>其中$\phi^{t}$代表的是在时间t的时候模型和它当时的参数。</p><script type="math/tex; mode=display">q_{s, r, o, t^{\prime}}^{t}=\frac{\exp \left(\phi^{t}\left(s, r, o, t^{\prime}\right)\right)}{\sum_{o^{\prime} \in D_{s, r, t^{\prime}}^{-}} \exp \left(\phi^{t}\left(s, r, o^{\prime}, t^{\prime}\right)\right)}</script><p>每次迭代replay knowledge distillation （重播知识蒸馏RKD）的损失和重播交叉熵（RCE）损失定义如下：</p><script type="math/tex; mode=display">\begin{aligned}L_{R K D} &=\sum_{s, r, o, t^{\prime} \in P t} D_{K L}\left(q_{s, r, o, t^{\prime}}^{t-1} \| q_{s, r, o, t^{\prime}}^{t}\right) \\&=\sum_{s, r, o, t^{\prime} \in P^{t}} q_{s, r, o, t^{\prime}}^{t-1} \log \left(\frac{q_{s, r, o, t^{\prime}}^{t-1}}{q_{s, r, o, t^{\prime}}^{t}}\right) \\L_{R C E} &=-\sum_{s, r, o, t^{\prime} \in P t} \log \left(q_{s, r, o, t^{\prime}}^{t}\right)\end{aligned}</script><h3 id="Temporal-Regularization-时间正则化"><a href="#Temporal-Regularization-时间正则化" class="headerlink" title="Temporal Regularization 时间正则化"></a>Temporal Regularization 时间正则化</h3><p>$\theta^{t-1}$表示在时间t-1之后训练的模型参数，$\theta^{t-1}={E^{t-1},R^{t-1},W^{t-1},B^{t-1}}$,其中𝑾和𝑩是编码过程中的权重和偏差参数的矩阵。举例，使用Diachronic Embedding (DE)作为本文的Encoder时，定义如下：</p><script type="math/tex; mode=display">z_{i}^{t}[n]=\left\{\begin{array}{ll}z_{i}[n] \sigma\left(w_{i}[n] t+b_{i}[n]\right) & \text { if } 1 \leq n \leq \gamma d \\z_{i}[n] & \text { if } \gamma d<n \leq d\end{array}\right.</script><p>$z_{i}$代表的是实体编码，维度是$|E|\times d$，前$\gamma d$个元素捕获时序、动态的信息，后$1-\gamma$个元素捕获静态的信息。</p><p>在时间步𝑡训练之前，我们使用$\theta^{t-1}$来初始化$\theta^t$，其中，实体的编码初始化如下：</p><script type="math/tex; mode=display">E_{i}^{t}=\left\{\begin{array}{ll}E_{i}^{t-1}, & \text { if } i \in E_{k n o w n}^{t-1} \\\text { uniform }\left(-\sqrt{\frac{12}{d}}, \sqrt{\frac{12}{d}}\right), & \text { otherwise. }\end{array}\right.</script><p>作者提出了对参数空间进行时间正则化以减轻TKG表示学习中的严重遗忘问题（catastrophic forgetting）：</p><script type="math/tex; mode=display">\begin{aligned}L_{T R}=\left\|\hat{\boldsymbol{E}}^{t}-\boldsymbol{E}^{t-1}\right\|_{2}+\left\|\hat{\boldsymbol{W}}^{t}-\boldsymbol{W}^{t-1}\right\|_{2}&+\left\|\hat{\boldsymbol{B}}^{t}-\boldsymbol{B}^{t-1}\right\|_{2}+\left\|\hat{\boldsymbol{R}}^{t}-\boldsymbol{R}^{t-1}\right\|_{2} .\end{aligned}</script><p>其中$\hat{\boldsymbol{E}}^{t}=\boldsymbol{E}^{t}\left[E_{k n o w n}^{t-1}\right]$。</p><h3 id="Learning-With-Deleted-Facts"><a href="#Learning-With-Deleted-Facts" class="headerlink" title="Learning With Deleted Facts"></a>Learning With Deleted Facts</h3><p>为了减轻模型的顽固性问题，作者提出可以使用时序变化中被删除的四元组来训练模型：</p><script type="math/tex; mode=display">N^{t}=\left\{(s, r, o, t) \mid(s, r, o, t) \notin D^{t} \wedge \exists t^{\prime},\left(s, r, o, t^{\prime}\right) \in B^{t}\right\}</script><p>我们将$N^t$中的每个四元组与一个负标签相关联，并计算二进制交叉熵损失为： </p><script type="math/tex; mode=display">L_{d e l}=-\sum_{(s, r, o, t) \in N^{t}} \log (1-\sigma(\phi(s, r, o, t)))</script><h3 id="Learning-With-Added-Facts"><a href="#Learning-With-Added-Facts" class="headerlink" title="Learning With Added Facts"></a>Learning With Added Facts</h3><p><img src='./img/16.4.png' style='width:60%'></p><p>我们通过Wikidata12k和YAGP11k的统计数据观察到，除了时间属性外，大多数事实在时间步长t-1和t之间是共同的。 这表明使用𝐷内的所有四元组进行微调实质上只是重新强调了该模型先前已知道的大多数事实。 </p><p>作者提出了一种新策略，就是仅用添加的事实来进行微调训练，这样做可以减小训练数据的大小，从而将训练速度提高几个数量级：</p><script type="math/tex; mode=display">\begin{aligned}D_{a d d}^{t} &=\left\{(s, r, o, t) \mid(s, r, o, t) \in D^{t} \wedge(s, r, o, t-1) \notin D^{t-1}\right\}, \\L_{C E} &=-\sum_{(s, r, o, t) \in D_{a d d}^{t}} \log \left(q_{s, r, o, t}^{t}\right)\end{aligned}</script><h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><p>最后TIE的损失函数被定义为前面几个阶段损失函数的加权和：</p><script type="math/tex; mode=display">L=\alpha_{1} L_{C E}+\alpha_{2} L_{d e l}+\alpha_{3} L_{R C E}+\alpha_{4} L_{R K D}+\alpha_{5} L_{T R}</script><p><img src='./img/16.3.png' style='width:60%'></p><p><img src='./img/16.1.png'></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="数据集分析"><a href="#数据集分析" class="headerlink" title="数据集分析"></a>数据集分析</h3><p><img src='./img/16.5.png' style='width:60%'></p><h3 id="实验设定"><a href="#实验设定" class="headerlink" title="实验设定"></a>实验设定</h3><p><img src='./img/16.6.png' style='width:60%'></p><p>使用前70%个时间步的数据进行标准的TKGC任务和评估，最后30%的时间步上使用增量的TKGC训练和评估方式完成实验。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src='./img/16.7.png' style='width:100%'></p><p>其中</p><ol><li>C@10, or C-Hits@10 (↑): Current Hits@10</li><li>DF@10, or DF-Hits@10 (↓) : Deleted Facts Hits@10.</li><li>RRD (↑) : Reciprocal Rank Difference.</li><li>A@10, or A-Hits@10 (↑) : Average Hits@10.</li></ol><p>比较的不同实验设置：</p><ol><li>Fine-tune (FT)：一个基本的baseline加上仅使用新增的数据进行微调训练。</li><li>Temporal Regularization (TR)：在FT的基础上加上了时间正则化损失进行训练。</li><li>The proposed complete model (TIE)：完整的TIE框架。</li><li>Full-batch (FB): 在这个实验中，使用$B^t$和$D^t$中的所有四元组进行微调模型。</li><li>Full-batch with future data (FB_future):这个实验中，使用${D^1,…,D^T}$的所有数据，即standard TKGC</li></ol>]]></content>
    
    
    <categories>
      
      <category>论文解读</category>
      
      <category>时序知识图谱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KGC</tag>
      
      <tag>Temporal Knowledge Graph</tag>
      
      <tag>Incremental Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MetaR:通过元学习进行知识图谱小样本链路预测</title>
    <link href="/2021/05/09/1.Meta-Relation-Learning%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    <url>/2021/05/09/1.Meta-Relation-Learning%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<center style="font-size:30px">Meta Relational Learning for Few-Shot Link Prediction in Knowledge Graphs</center><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>当前很多知识图谱是不完整的——缺少三元组(h,r,t)的形式，本文针对用来补全知识图谱的小样本链路预测任务，其主要作用是根据已有的三元组预测新的三元组。在目前的知识图谱中，少样本问题广泛存在。在Wikidata中，约10%的关系涉及的三元组不超过10个。</p><p>论文中将不同关系（如CountryCapital, CEOof等）涉及的三元组实体链接预测视为一个单独的任务，在测试的过程中使用训练集中未出现的关系链接预测作为新的任务。</p><p><img src="./img/1.1.png"></p><p><img src="./img/1.6.png"></p><h2 id="Relation-specific-meta-information"><a href="#Relation-specific-meta-information" class="headerlink" title="Relation-specific meta information"></a>Relation-specific meta information</h2><p>关系特定元信息是从小样本中转换到未完善的三元组中的最重要的信息，即在一个相同的任务中应该是相同以及共享的知识。</p><p>关系特定元信息可以从以下两个方面帮助我们进行链路预测：</p><ol><li>从观察的存在的三元组中传输相同的关系信息到不完整的三元组中</li><li>仅仅通过观察少量样本就能加速一个任务的学习过程</li></ol><p>同时，基于上述的两个特点，本文提出了两种关系特定元信息：关系元和梯度元。在本文提出的MetaR框架中，关系元是连接头实体和尾实体的关系的高级表示；梯度元则是在预测任务—将关系元传输到不完整的三元组关系之前，用来快速更新的关系元的梯度损失。（也就是说，在关系元信息传递到不完整的三元组的时候，已经利用梯度元将关系元更新成一个稳定的信息表示）</p><h2 id="Meta-Learning"><a href="#Meta-Learning" class="headerlink" title="Meta-Learning"></a>Meta-Learning</h2><p>元学习的目标是为了对于小样本寻找一个快速学习的能力，并且将这种学习能力泛化到更多的概念中。这种学习的模式接近于人类的学习方式。它可以看作是寻找一个向量空间上的任务的基，学习任务的本质，我们并不是通过学习具体任务（例如统计学习）来学会新的任务，而是通过抓住这些任务的本质以促进新任务的学习。</p><h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ol><li><p>提出了一个用来针对小样本链接预测的元关系学习MetaR框架(传统的嵌入式模型需要依靠大量的训练数据，这就限制了其在小样本链路预测任务上的应用)</p></li><li><p>我们强调了具体的元关系信息在小样本链接预测任务中的重要地位，并且提出了两种具体的关系元信息</p></li><li><p>本文提出的MetaR框架在小样本链接预测任务上达到了最高水平，除此之外我们还分析了影响MetaR框架表现的具体因素</p></li></ol><h2 id="任务制定"><a href="#任务制定" class="headerlink" title="任务制定"></a>任务制定</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li><p>知识图谱 $\mathcal{G}= { \mathcal{E,R,TP} }$，$\mathcal{E}$是实体集合，$\mathcal{R}$是关系集合，$\mathcal{TP={(h,r,t)\in E \times R \times E}}$是三元组集合。</p></li><li><p>小样本链路预测任务$\mathcal{T}$ 在一个知识图谱$\mathcal{G}$中，给定一个支持集$\mathcal{S_r={(h_i,t_i)\in E\times E \vert } $ $ \mathcal{(h_i,r,t_i)\in TP}}$ ，其中关系$\mathcal{r \in R}$，如果$\mathcal{|S_r|=K}$，那么预测和某个头节点$h_j$有着关系$r$的尾节点的任务就叫做K-样本连接预测预测，写作$r:(h_j,?)$。</p><p>通过上面的定义，一个小样本的链接预测任务通常定义在一个具体的关系上。在预测的过程中，通常有超过一个的三元组需要被预测。与支持集$\mathcal{S_r}$相对应的是，我们定义一系列的需要被预测三元组，称之为查询集$Q_r = { r : ( h_j , ? )}$。</p></li></ol><h2 id="MetaR结构"><a href="#MetaR结构" class="headerlink" title="MetaR结构"></a>MetaR结构</h2><p><img src="./img/1.2.png"></p><h3 id="Relation-Meta-Learner"><a href="#Relation-Meta-Learner" class="headerlink" title="Relation-Meta Learner"></a>Relation-Meta Learner</h3><p>作用主要是从提供的Support Set中提取关系元，这个学习机的结构是用一个简单的神经网络。</p><p><img src="./img/1.3.png"></p><p>在任务$\mathcal{T_r}$中，学习机的输入是给定的Support Set里面的头尾实体对${(h_i,t_i)\in S_r}$，我们首次通过一个$L$层的神经网络提取出这些实体对的具体的关系元(specific relation meta)</p><script type="math/tex; mode=display">\begin{aligned} \mathrm{x}^0&=\mathrm{h}_i⊕\mathrm{t}_i\\\mathrm{x}^l&=\sigma(\mathrm{W}^l\mathrm{x}^{l-1}+b^l)\\R_{(h_i,t_i)}&=\mathrm{W}^L\mathrm{x}^{L-1}+b^L \end{aligned}</script><p>$\large \mathrm{h}<em>i\in \mathbb{R}^d,\mathrm{t}_i\in \mathbb{R}^d$，是头实体$h_i$和尾实体$t_i$分别在d维空间的嵌入.$\mathrm{W}^l$和$b^l$分别是神经网络$l$层的权重和偏移。$\sigma $函数使用了LeakyReLU激活函数，$\mathrm{x⊕y}$代表向量拼接，最后的到的$R</em>{(h_i,t_i)}$代表了特定实体$h_i$和$t_i$的关系元。</p><script type="math/tex; mode=display">R_{\mathcal{T_r}}= \frac{\sum_{i=1}^{K}R_{(h_i,t_i)}}{K}</script><p>有了很多实体对的特定关系元后，我们最后计算当前任务$\mathcal{T<em>r}$的最终关系元$R</em>{\mathcal{T_r}}$。</p><h3 id="Embedding-Learner"><a href="#Embedding-Learner" class="headerlink" title="Embedding Learner"></a>Embedding Learner</h3><script type="math/tex; mode=display">s_{(h_i,t_i)}=||\mathrm{h}_i+R_{\mathcal{T_r}}-\mathrm{t}_i||</script><p>$||\mathrm{x}||$代表向量的L2范式，这种评分函数的基本思想来源于TransE模型，其假设的是一个真实的三元组满足$\mathrm{h+r=t}$的基本假设。因此这个评分函数定义的是$\mathrm{h+r}$和$\LARGE \mathrm{t}$之间的距离。这个方式转换到我们的链接预测中，由于我们的任务中没有直接普遍的关系嵌入编码，我们使用关系元信息$R<em>{\mathcal{T_r}}$来替代编码获得的关系$\mathrm{r}$，$R</em>{\mathcal{T_r}}$可以视为任务$\mathcal{T_r}$的关系编码。</p><p>本文对每个三元组都进行了评分，并且设置了以下的合页损失函数：</p><script type="math/tex; mode=display">L(S_r)=\sum_{(h_i,t_i)\in S_r}[\gamma+s_{(h_i,t_i)}-s_{(h_i,t'_i)}]_+</script><p>其中$[x]<em>+$表示的是样本x的positive part，$\gamma$是表示距离的超参数。$s</em>{(h_i,t’_i)}$是相对于正例实体对$(h_i,t_i)\in \mathcal{S_r}$的反例实体对$(h_i,t’_i)$，即$(h_i,r,t’_i)\notin \mathcal{G}$</p><p>我们将基于$L(\mathcal{S<em>r})$的关系元$R</em>{\mathcal{T<em>r}}$的梯度作为梯度元$G</em>{\mathcal{T_r}}$:</p><script type="math/tex; mode=display">G_{\mathcal{T_r}}=\nabla_{R_{\mathcal{T_r}}}L(S_r)</script><p>并且通过以下函数更新关系元:</p><script type="math/tex; mode=display">R'_{\mathcal{T_r}}=R_{\mathcal{T_r}}-\beta G_{\mathcal{T_r}}</script><p>其中β为利用梯度元对关系元进行更新的步长因子，通过这个式子让模型在每个任务中精调。</p><p>当基于编码学习器来对查询集中的实体进行评分的时候，我们使用更新之后的关系元。在获取到更新之后的关系元$R’$之后，我们将其转移到查询集$\mathcal{Q}_r={(h_j,t_j)}$中，然后计算其评分和查询集(Query Set)的损失情况，其计算评分和计算损失的公式和支持集(Support Set)中一样。</p><script type="math/tex; mode=display">s(h_j,t_j)=||\mathrm{h}_j+R'_{\mathcal{T_r}}-\mathrm{t_j}||\\L(\mathcal{Q}_r)=\sum_{(h_j,t_j)\in \mathcal{Q_r}}[\gamma+s_{(h_j,t_j)}-s_{(h_j,t'_j)}]_+</script><p>使$L(\mathcal{Q}_r)$最小化就是我们这个训练的目标，我们通过这个参数去更新整个模型。</p><script type="math/tex; mode=display">L=\sum_\mathcal{(S_r,Q_r)\in T_{train}}L(\mathcal{Q_r})</script><p>在训练中，我们的目的就是最小化$L$损失函数，他是各个任务中查询集损失函数的和。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="./img/1.5.png"></p><p>MRR（Mean reciprocal rank）是一个国际上通用的对搜索算法进行评价的机制，即第一个结果匹配，分数为1，第二个匹配分数为0.5，第n个匹配分数为1/n，如果没有匹配的句子分数为0。最终的分数为所有得分之和。Hits@N代表正项在链路预测可能性的top N个实体中的比例。</p><p>粗体的数字代表所有对比项中最好的结果，下划线数字代表GMatching中最好的结果。</p>]]></content>
    
    
    <categories>
      
      <category>论文解读</category>
      
      <category>小样本知识图谱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Few-Shot Knowledge Graph</tag>
      
      <tag>Meta Learning</tag>
      
      <tag>KGC</tag>
      
      <tag>Link Prediction</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
</search>
